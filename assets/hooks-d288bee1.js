import{R as Z,a as $r,r as gt}from"./index-ca859ab0.js";function Mr(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Ir=Mr,I=Ir;function Ur(e){return!!e&&typeof e.then=="function"}var G=Ur;function kr(e,t){if(e!=null)return e;throw I(t??"Got unexpected null or undefined")}var j=kr;function M(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class bt{getValue(){throw I("BaseLoadable")}toPromise(){throw I("BaseLoadable")}valueMaybe(){throw I("BaseLoadable")}valueOrThrow(){throw I(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw I("BaseLoadable")}promiseOrThrow(){throw I(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw I("BaseLoadable")}errorOrThrow(){throw I(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw I("BaseLoadable")}}class Dr extends bt{constructor(t){super(),M(this,"state","hasValue"),M(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return G(n)?Ne(n):Pe(n)?n:ot(n)}catch(n){return G(n)?Ne(n.next(()=>this.map(t))):Tt(n)}}}class Br extends bt{constructor(t){super(),M(this,"state","hasError"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Jn extends bt{constructor(t){super(),M(this,"state","loading"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Ne(this.contents.then(n=>{const o=t(n);if(Pe(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(G(n))return n.then(()=>this.map(t).contents);throw n}))}}function ot(e){return Object.freeze(new Dr(e))}function Tt(e){return Object.freeze(new Br(e))}function Ne(e){return Object.freeze(new Jn(e))}function Qn(){return Object.freeze(new Jn(new Promise(()=>{})))}function Pr(e){return e.every(t=>t.state==="hasValue")?ot(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?Tt(j(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Ne(Promise.all(e.map(t=>t.contents)))}function eo(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Pe(r)?r:G(r)?Ne(r):ot(r)),o=Pr(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,s,l)=>({...a,[s]:r[l]}),{}))}function Pe(e){return e instanceof bt}const Or={of:e=>G(e)?Ne(e):Pe(e)?e:ot(e),error:e=>Tt(e),loading:()=>Qn(),all:eo,isLoadable:Pe};var Ce={loadableWithValue:ot,loadableWithError:Tt,loadableWithPromise:Ne,loadableLoading:Qn,loadableAll:eo,isLoadable:Pe,RecoilLoadable:Or},xr=Ce.loadableWithValue,Fr=Ce.loadableWithError,zr=Ce.loadableWithPromise,Wr=Ce.loadableLoading,Gr=Ce.loadableAll,Kr=Ce.isLoadable,Hr=Ce.RecoilLoadable,rt=Object.freeze({__proto__:null,loadableWithValue:xr,loadableWithError:Fr,loadableWithPromise:zr,loadableLoading:Wr,loadableAll:Gr,isLoadable:Kr,RecoilLoadable:Hr});const en={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function qr(e,t){var n,o;const r=(n=process.env[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw I(`({}).${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function jr(e,t){var n;const o=(n=process.env[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function Zr(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(qr("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{en.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),jr("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{en.RECOIL_GKS_ENABLED.add(n)})}))}Zr();var We=en;function wt(e){return We.RECOIL_GKS_ENABLED.has(e)}wt.setPass=e=>{We.RECOIL_GKS_ENABLED.add(e)};wt.setFail=e=>{We.RECOIL_GKS_ENABLED.delete(e)};wt.clear=()=>{We.RECOIL_GKS_ENABLED.clear()};var W=wt;function Yr(e,t,{error:n}={}){return null}var Xr=Yr,un=Xr,Ht,qt,jt;const Jr=(Ht=Z.createMutableSource)!==null&&Ht!==void 0?Ht:Z.unstable_createMutableSource,to=(qt=Z.useMutableSource)!==null&&qt!==void 0?qt:Z.unstable_useMutableSource,no=(jt=Z.useSyncExternalStore)!==null&&jt!==void 0?jt:Z.unstable_useSyncExternalStore;function Qr(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=Z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;return((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null}function ea(){return W("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:W("recoil_sync_external_store")&&no!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:W("recoil_mutable_source")&&to!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?W("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:W("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function ta(){return!1}var at={createMutableSource:Jr,useMutableSource:to,useSyncExternalStore:no,currentRendererSupportsUseSyncExternalStore:Qr,reactMode:ea,isFastRefreshEnabled:ta};class dn{constructor(t){M(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class oo extends dn{}class ro extends dn{}function na(e){return e instanceof oo||e instanceof ro}var Et={AbstractRecoilValue:dn,RecoilState:oo,RecoilValueReadOnly:ro,isRecoilValue:na},oa=Et.AbstractRecoilValue,ra=Et.RecoilState,aa=Et.RecoilValueReadOnly,sa=Et.isRecoilValue,Oe=Object.freeze({__proto__:null,AbstractRecoilValue:oa,RecoilState:ra,RecoilValueReadOnly:aa,isRecoilValue:sa});function ia(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var At=ia;class ao{}const ca=new ao,Le=new Map,fn=new Map;function la(e){return At(e,t=>j(fn.get(t)))}function ua(e){if(Le.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function da(e){We.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&ua(e.key),Le.set(e.key,e);const t=e.set==null?new Oe.RecoilValueReadOnly(e.key):new Oe.RecoilState(e.key);return fn.set(e.key,t),t}class so extends Error{}function fa(e){const t=Le.get(e);if(t==null)throw new so(`Missing definition for RecoilValue: "${e}""`);return t}function ha(e){return Le.get(e)}const St=new Map;function va(e){var t;if(!W("recoil_memory_managament_2020"))return;const n=Le.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Le.delete(e),(o=io(e))===null||o===void 0||o(),St.delete(e)}}function pa(e,t){W("recoil_memory_managament_2020")&&(t===void 0?St.delete(e):St.set(e,t))}function io(e){return St.get(e)}var ce={nodes:Le,recoilValues:fn,registerNode:da,getNode:fa,getNodeMaybe:ha,deleteNodeConfigIfPossible:va,setConfigDeletionHandler:pa,getConfigDeletionHandler:io,recoilValuesForKeys:la,NodeMissingError:so,DefaultValue:ao,DEFAULT_VALUE:ca};function _a(e,t){t()}var Sa={enqueueExecution:_a};function ma(e,t){return t={exports:{}},e(t,t.exports),t.exports}var Ra=ma(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,s=r/2,l=r/4,u={},f=function(i){return function(){return i}},v=n.hash=function(c){var i=typeof c>"u"?"undefined":t(c);if(i==="number")return c;i!=="string"&&(c+="");for(var h=0,m=0,R=c.length;m<R;++m){var g=c.charCodeAt(m);h=(h<<5)-h+g|0}return h},p=function(i){return i-=i>>1&1431655765,i=(i&858993459)+(i>>2&858993459),i=i+(i>>4)&252645135,i+=i>>8,i+=i>>16,i&127},A=function(i,h){return h>>>i&a},V=function(i){return 1<<i},y=function(i,h){return p(i&h-1)},E=function(i,h,m,R){var g=R;if(!i){var C=R.length;g=new Array(C);for(var N=0;N<C;++N)g[N]=R[N]}return g[h]=m,g},Y=function(i,h,m){var R=m.length-1,g=0,C=0,N=m;if(i)g=C=h;else for(N=new Array(R);g<h;)N[C++]=m[g++];for(++g;g<=R;)N[C++]=m[g++];return i&&(N.length=R),N},te=function(i,h,m,R){var g=R.length;if(i){for(var C=g;C>=h;)R[C--]=R[C];return R[h]=m,R}for(var N=0,L=0,U=new Array(g+1);N<h;)U[L++]=R[N++];for(U[h]=m;N<g;)U[++L]=R[N++];return U},w=1,B=2,Q=3,z=4,K={__hamt_isEmpty:!0},X=function(i){return i===K||i&&i.__hamt_isEmpty},ae=function(i,h,m,R){return{type:w,edit:i,hash:h,key:m,value:R,_modify:Ie}},me=function(i,h,m){return{type:B,edit:i,hash:h,children:m,_modify:Ue}},x=function(i,h,m){return{type:Q,edit:i,mask:h,children:m,_modify:P}},re=function(i,h,m){return{type:z,edit:i,size:h,children:m,_modify:O}},we=function(i){return i===K||i.type===w||i.type===B},oe=function(i,h,m,R,g){for(var C=[],N=R,L=0,U=0;N;++U)N&1&&(C[U]=g[L++]),N>>>=1;return C[h]=m,re(i,L+1,C)},le=function(i,h,m,R){for(var g=new Array(h-1),C=0,N=0,L=0,U=R.length;L<U;++L)if(L!==m){var q=R[L];q&&!X(q)&&(g[C++]=q,N|=1<<L)}return x(i,N,g)},$e=function c(i,h,m,R,g,C){if(m===g)return me(i,m,[C,R]);var N=A(h,m),L=A(h,g);return x(i,V(N)|V(L),N===L?[c(i,h+o,m,R,g,C)]:N<L?[R,C]:[C,R])},Me=function(i,h,m,R,g,C,N,L){for(var U=g.length,q=0;q<U;++q){var se=g[q];if(m(N,se.key)){var ne=se.value,fe=C(ne);return fe===ne?g:fe===u?(--L.value,Y(i,q,g)):E(i,q,ae(h,R,N,fe),g)}}var ve=C();return ve===u?g:(++L.value,E(i,U,ae(h,R,N,ve),g))},Re=function(i,h){return i===h.edit},Ie=function(i,h,m,R,g,C,N){if(h(C,this.key)){var L=R(this.value);return L===this.value?this:L===u?(--N.value,K):Re(i,this)?(this.value=L,this):ae(i,g,C,L)}var U=R();return U===u?this:(++N.value,$e(i,m,this.hash,this,g,ae(i,g,C,U)))},Ue=function(i,h,m,R,g,C,N){if(g===this.hash){var L=Re(i,this),U=Me(L,i,h,this.hash,this.children,R,C,N);return U===this.children?this:U.length>1?me(i,this.hash,U):U[0]}var q=R();return q===u?this:(++N.value,$e(i,m,this.hash,this,g,ae(i,g,C,q)))},P=function(i,h,m,R,g,C,N){var L=this.mask,U=this.children,q=A(m,g),se=V(q),ne=y(L,se),fe=L&se,ve=fe?U[ne]:K,ke=ve._modify(i,h,m+o,R,g,C,N);if(ve===ke)return this;var ut=Re(i,this),He=L,qe=void 0;if(fe&&X(ke)){if(He&=~se,!He)return K;if(U.length<=2&&we(U[ne^1]))return U[ne^1];qe=Y(ut,ne,U)}else if(!fe&&!X(ke)){if(U.length>=s)return oe(i,q,ke,L,U);He|=se,qe=te(ut,ne,ke,U)}else qe=E(ut,ne,ke,U);return ut?(this.mask=He,this.children=qe,this):x(i,He,qe)},O=function(i,h,m,R,g,C,N){var L=this.size,U=this.children,q=A(m,g),se=U[q],ne=(se||K)._modify(i,h,m+o,R,g,C,N);if(se===ne)return this;var fe=Re(i,this),ve=void 0;if(X(se)&&!X(ne))++L,ve=E(fe,q,ne,U);else if(!X(se)&&X(ne)){if(--L,L<=l)return le(i,L,q,U);ve=E(fe,q,K,U)}else ve=E(fe,q,ne,U);return fe?(this.size=L,this.children=ve,this):re(i,L,ve)};K._modify=function(c,i,h,m,R,g,C){var N=m();return N===u?K:(++C.value,ae(c,R,g,N))};function d(c,i,h,m,R){this._editable=c,this._edit=i,this._config=h,this._root=m,this._size=R}d.prototype.setTree=function(c,i){return this._editable?(this._root=c,this._size=i,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,i)};var _=n.tryGetHash=function(c,i,h,m){for(var R=m._root,g=0,C=m._config.keyEq;;)switch(R.type){case w:return C(h,R.key)?R.value:c;case B:{if(i===R.hash)for(var N=R.children,L=0,U=N.length;L<U;++L){var q=N[L];if(C(h,q.key))return q.value}return c}case Q:{var se=A(g,i),ne=V(se);if(R.mask&ne){R=R.children[y(R.mask,ne)],g+=o;break}return c}case z:{if(R=R.children[A(g,i)],R){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,i,h){return _(c,i,h,this)};var S=n.tryGet=function(c,i,h){return _(c,h._config.hash(i),i,h)};d.prototype.tryGet=function(c,i){return S(c,i,this)};var $=n.getHash=function(c,i,h){return _(void 0,c,i,h)};d.prototype.getHash=function(c,i){return $(c,i,this)},n.get=function(c,i){return _(void 0,i._config.hash(c),c,i)},d.prototype.get=function(c,i){return S(i,c,this)};var b=n.has=function(c,i,h){return _(u,c,i,h)!==u};d.prototype.hasHash=function(c,i){return b(c,i,this)};var D=n.has=function(c,i){return b(i._config.hash(c),c,i)};d.prototype.has=function(c){return D(c,this)};var k=function(i,h){return i===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||k,hash:c&&c.hash||v},K,0)},n.empty=n.make();var T=n.isEmpty=function(c){return c&&!!X(c._root)};d.prototype.isEmpty=function(){return T(this)};var H=n.modifyHash=function(c,i,h,m){var R={value:m._size},g=m._root._modify(m._editable?m._edit:NaN,m._config.keyEq,0,c,i,h,R);return m.setTree(g,R.value)};d.prototype.modifyHash=function(c,i,h){return H(h,c,i,this)};var ee=n.modify=function(c,i,h){return H(c,h._config.hash(i),i,h)};d.prototype.modify=function(c,i){return ee(i,c,this)};var F=n.setHash=function(c,i,h,m){return H(f(h),c,i,m)};d.prototype.setHash=function(c,i,h){return F(c,i,h,this)};var J=n.set=function(c,i,h){return F(h._config.hash(c),c,i,h)};d.prototype.set=function(c,i){return J(c,i,this)};var he=f(u),Ee=n.removeHash=function(c,i,h){return H(he,c,i,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,i){return Ee(c,i,this)};var de=n.remove=function(c,i){return Ee(i._config.hash(c),c,i)};d.prototype.remove=d.prototype.delete=function(c){return de(c,this)};var ue=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return ue(this)};var An=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return An(this)};var gr=n.mutate=function(c,i){var h=ue(i);return c(h),An(h)};d.prototype.mutate=function(c){return gr(c,this)};var Wt=function(i){return i&&Nn(i[0],i[1],i[2],i[3],i[4])},Nn=function(i,h,m,R,g){for(;m<i;){var C=h[m++];if(C&&!X(C))return Ln(C,R,[i,h,m,R,g])}return Wt(g)},Ln=function(i,h,m){switch(i.type){case w:return{value:h(i),rest:m};case B:case z:case Q:var R=i.children;return Nn(R.length,R,0,h,m);default:return Wt(m)}},br={done:!0};function Gt(c){this.v=c}Gt.prototype.next=function(){if(!this.v)return br;var c=this.v;return this.v=Wt(c.rest),c},Gt.prototype[Symbol.iterator]=function(){return this};var Kt=function(i,h){return new Gt(Ln(i._root,h))},Tr=function(i){return[i.key,i.value]},wr=n.entries=function(c){return Kt(c,Tr)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return wr(this)};var Er=function(i){return i.key},Ar=n.keys=function(c){return Kt(c,Er)};d.prototype.keys=function(){return Ar(this)};var Nr=function(i){return i.value},Lr=n.values=d.prototype.values=function(c){return Kt(c,Nr)};d.prototype.values=function(){return Lr(this)};var Cn=n.fold=function(c,i,h){var m=h._root;if(m.type===w)return c(i,m.value,m.key);for(var R=[m.children],g=void 0;g=R.pop();)for(var C=0,N=g.length;C<N;){var L=g[C++];L&&L.type&&(L.type===w?i=c(i,L.value,L.key):R.push(L.children))}return i};d.prototype.fold=function(c,i){return Cn(c,i,this)};var Cr=n.forEach=function(c,i){return Cn(function(h,m,R){return c(m,R,i)},null,i)};d.prototype.forEach=function(c){return Cr(c,this)};var Vr=n.count=function(c){return c._size};d.prototype.count=function(){return Vr(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class ya{constructor(t){M(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return vn(this)}toMap(){return new Map(this._map)}}class hn{constructor(t){if(M(this,"_hamt",Ra.empty.beginMutation()),t instanceof hn){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return vn(this)}toMap(){return new Map(this._hamt)}}function vn(e){return W("recoil_hamt_2020")?new hn(e):new ya(e)}var ga={persistentMap:vn},ba=ga.persistentMap,Ta=Object.freeze({__proto__:null,persistentMap:ba});function wa(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var et=wa;function Ea(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var mt=Ea;function Aa(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function Na(e){return{nodeDeps:mt(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:mt(e.nodeToNodeSubscriptions,t=>new Set(t))}}function Zt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,s=r.get(e);if(s&&o&&s!==o.nodeDeps.get(e))return;r.set(e,t);const l=s==null?t:et(t,s);for(const u of l)a.has(u)||a.set(u,new Set),j(a.get(u)).add(e);if(s){const u=et(s,t);for(const f of u){if(!a.has(f))return;const v=j(a.get(f));v.delete(e),v.size===0&&a.delete(f)}}}function La(e,t,n,o){var r,a,s,l;const u=n.getState();o===u.currentTree.version||o===((r=u.nextTree)===null||r===void 0?void 0:r.version)||((a=u.previousTree)===null||a===void 0||a.version);const f=n.getGraph(o);if(Zt(e,t,f),o===((s=u.previousTree)===null||s===void 0?void 0:s.version)){const p=n.getGraph(u.currentTree.version);Zt(e,t,p,f)}if(o===((l=u.previousTree)===null||l===void 0?void 0:l.version)||o===u.currentTree.version){var v;const p=(v=u.nextTree)===null||v===void 0?void 0:v.version;if(p!==void 0){const A=n.getGraph(p);Zt(e,t,A,f)}}}var st={cloneGraph:Na,graph:Aa,saveDepsToStore:La};let Ca=0;const Va=()=>Ca++;let $a=0;const Ma=()=>$a++;let Ia=0;const Ua=()=>Ia++;var Nt={getNextTreeStateVersion:Va,getNextStoreID:Ma,getNextComponentID:Ua};const{persistentMap:Vn}=Ta,{graph:ka}=st,{getNextTreeStateVersion:co}=Nt;function lo(){const e=co();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Vn(),nonvalidatedAtoms:Vn()}}function Da(){const e=lo();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,ka()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var uo={makeEmptyTreeState:lo,makeEmptyStoreState:Da,getNextTreeStateVersion:co};class fo{}function Ba(){return new fo}var Lt={RetentionZone:fo,retentionZone:Ba};function Pa(e,t){const n=new Set(e);return n.add(t),n}function Oa(e,t){const n=new Set(e);return n.delete(t),n}function xa(e,t,n){const o=new Map(e);return o.set(t,n),o}function Fa(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function za(e,t){const n=new Map(e);return n.delete(t),n}function Wa(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var ho={setByAddingToSet:Pa,setByDeletingFromSet:Oa,mapBySettingInMap:xa,mapByUpdatingInMap:Fa,mapByDeletingFromMap:za,mapByDeletingMultipleFromMap:Wa};function*Ga(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var pn=Ga;function Ka(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var vo=Ka;const{getNode:it,getNodeMaybe:Ha,recoilValuesForKeys:$n}=ce,{RetentionZone:Mn}=Lt,{setByAddingToSet:qa}=ho,ja=Object.freeze(new Set);class Za extends Error{}function Ya(e,t,n){if(!W("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let s=o.get(a);s||o.set(a,s=new Set),s.add(t)}if(n instanceof Mn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!W("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function s(l){const u=a.nodesRetainedByZone.get(l);u==null||u.delete(t),u&&u.size===0&&a.nodesRetainedByZone.delete(l)}if(n instanceof Mn)s(n);else if(Array.isArray(n))for(const l of n)s(l)}}function _n(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=it(n),s=Ya(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),s()})}function Xa(e,t,n){_n(e,e.getState().currentTree,t,n)}function Ja(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function Qa(e,t,n){return _n(e,t,n,"get"),it(n).get(e,t)}function po(e,t,n){return it(n).peek(e,t)}function es(e,t,n){var o;const r=Ha(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:qa(e.dirtyAtoms,t)}}function ts(e,t,n,o){const r=it(n);if(r.set==null)throw new Za(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return _n(e,t,n,"set"),a(e,t,o)}function ns(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=it(n).nodeType;return vo({type:a},{loadable:()=>po(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var s;return $n((s=r.nodeDeps.get(n))!==null&&s!==void 0?s:[])},subscribers:()=>{var s,l;return{nodes:$n(pn(_o(e,t,new Set([n])),u=>u!==n)),components:At((s=(l=o.nodeToComponentSubscriptions.get(n))===null||l===void 0?void 0:l.values())!==null&&s!==void 0?s:[],([u])=>({name:u}))}}})}function _o(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var s;o.add(l);const u=(s=a.nodeToNodeSubscriptions.get(l))!==null&&s!==void 0?s:ja;for(const f of u)o.has(f)||r.push(f)}return o}var be={getNodeLoadable:Qa,peekNodeLoadable:po,setNodeValue:ts,initializeNode:Xa,cleanUpNode:Ja,setUnvalidatedAtomValue_DEPRECATED:es,peekNodeInfo:ns,getDownstreamNodes:_o};let So=null;function os(e){So=e}function rs(){var e;(e=So)===null||e===void 0||e()}var mo={setInvalidateMemoizedSnapshot:os,invalidateMemoizedSnapshot:rs};const{getDownstreamNodes:as,getNodeLoadable:Ro,setNodeValue:ss}=be,{getNextComponentID:is}=Nt,{getNode:cs,getNodeMaybe:yo}=ce,{DefaultValue:Sn}=ce,{reactMode:ls}=at,{AbstractRecoilValue:us,RecoilState:ds,RecoilValueReadOnly:fs,isRecoilValue:hs}=Oe,{invalidateMemoizedSnapshot:vs}=mo;function ps(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||(n.version,(r=a.previousTree)===null||r===void 0||r.version);const s=Ro(e,n,t);return s.state==="loading"&&s.contents.catch(()=>{}),s}function _s(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof Sn?n.delete(r):n.set(r,o)}),n}function Ss(e,t,{key:n},o){if(typeof o=="function"){const r=Ro(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw I(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function ms(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,s=Ss(e,t,r,a),l=ss(e,t,r.key,s);for(const[u,f]of l.entries())tn(t,u,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;tn(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,s=yo(r);s==null||(o=s.invalidate)===null||o===void 0||o.call(s,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else un(`Unknown action ${n.type}`)}function tn(e,t,n){n.state==="hasValue"&&n.contents instanceof Sn?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function go(e,t){e.replaceState(n=>{const o=bo(n);for(const r of t)ms(e,o,r);return To(e,o),vs(),o})}function Ct(e,t){if(tt.length){const n=tt[tt.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else go(e,[t])}const tt=[];function Rs(){const e=new Map;return tt.push(e),()=>{for(const[t,n]of e)go(t,n);tt.pop()}}function bo(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function To(e,t){const n=as(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=yo(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function wo(e,t,n){Ct(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function ys(e,t,n){if(n instanceof Sn)return wo(e,t,n);Ct(e,{type:"setLoadable",recoilValue:t,loadable:n})}function gs(e,t){Ct(e,{type:"markModified",recoilValue:t})}function bs(e,t,n){Ct(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Ts(e,{key:t},n,o=null){const r=is(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),j(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const s=ls();if(s.early&&(s.mode==="LEGACY"||s.mode==="MUTABLE_SOURCE")){const l=e.getState().nextTree;l&&l.dirtyAtoms.has(t)&&n(l)}return{release:()=>{const l=e.getState(),u=l.nodeToComponentSubscriptions.get(t);u===void 0||!u.has(r)||(u.delete(r),u.size===0&&l.nodeToComponentSubscriptions.delete(t))}}}function ws(e,t){var n;const{currentTree:o}=e.getState(),r=cs(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var _e={RecoilValueReadOnly:fs,AbstractRecoilValue:us,RecoilState:ds,getRecoilValueAsLoadable:ps,setRecoilValue:wo,setRecoilValueLoadable:ys,markRecoilValueModified:gs,setUnvalidatedRecoilValue:bs,subscribeToRecoilValue:Ts,isRecoilValue:hs,applyAtomValueWrites:_s,batchStart:Rs,writeLoadableToTreeState:tn,invalidateDownstreams:To,copyTreeState:bo,refreshRecoilValue:ws};function Es(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var As=Es;const{cleanUpNode:Ns}=be,{deleteNodeConfigIfPossible:Ls,getNode:Eo}=ce,{RetentionZone:Ao}=Lt,Cs=12e4,No=new Set;function Lo(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return;const r=new Set;for(const s of t)if(s instanceof Ao)for(const l of Is(n,s))r.add(l);else r.add(s);const a=Vs(e,r);for(const s of a)Ms(e,o,s)}function Vs(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return l(t),a;function l(u){const f=new Set,v=$s(e,o,u,a,s);for(const y of v){var p;if(Eo(y).retainedBy==="recoilRoot"){s.add(y);continue}if(((p=n.retention.referenceCounts.get(y))!==null&&p!==void 0?p:0)>0){s.add(y);continue}if(Co(y).some(Y=>n.retention.referenceCounts.get(Y))){s.add(y);continue}const E=r.nodeToNodeSubscriptions.get(y);if(E&&As(E,Y=>s.has(Y))){s.add(y);continue}a.add(y),f.add(y)}const A=new Set;for(const y of f)for(const E of(V=r.nodeDeps.get(y))!==null&&V!==void 0?V:No){var V;a.has(E)||A.add(E)}A.size&&l(A)}}function $s(e,t,n,o,r){const a=e.getGraph(t.version),s=[],l=new Set;for(;n.size>0;)u(j(n.values().next().value));return s;function u(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(l.has(f))return;const v=a.nodeToNodeSubscriptions.get(f);if(v)for(const p of v)u(p);l.add(f),n.delete(f),s.push(f)}}function Ms(e,t,n){if(!W("recoil_memory_managament_2020"))return;Ns(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=Co(n);for(const u of r){var a;(a=o.retention.nodesRetainedByZone.get(u))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const u=s.nodeDeps.get(n);if(u!==void 0){s.nodeDeps.delete(n);for(const f of u){var l;(l=s.nodeToNodeSubscriptions.get(f))===null||l===void 0||l.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}Ls(n)}function Is(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:No}function Co(e){const t=Eo(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof Ao?[t]:t}function Us(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):Lo(e,new Set([t]))}function ks(e,t,n){var o;if(!W("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Vo(e,t):r.set(t,a)}function Vo(e,t){if(!W("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Us(e,t)}function Ds(e){if(!W("recoil_memory_managament_2020"))return;const t=e.getState();Lo(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Bs(e){return e===void 0?"recoilRoot":e}var Ve={SUSPENSE_TIMEOUT_MS:Cs,updateRetainCount:ks,updateRetainCountToZero:Vo,releaseScheduledRetainablesNow:Ds,retainedByOptionWithDefault:Bs};const{unstable_batchedUpdates:Ps}=$r;var Os={unstable_batchedUpdates:Ps};const{unstable_batchedUpdates:xs}=Os;var Fs={unstable_batchedUpdates:xs};const{batchStart:zs}=_e,{unstable_batchedUpdates:Ws}=Fs;let mn=Ws||(e=>e());const Gs=e=>{mn=e},Ks=()=>mn,Hs=e=>{mn(()=>{let t=()=>{};try{t=zs(),e()}finally{t()}})};var Vt={getBatcher:Ks,setBatcher:Gs,batchUpdates:Hs};function*qs(e){for(const t of e)for(const n of t)yield n}var $o=qs;const Mo=typeof Window>"u"||typeof window>"u",js=e=>!Mo&&(e===window||e instanceof Window),Zs=typeof navigator<"u"&&navigator.product==="ReactNative";var $t={isSSR:Mo,isReactNative:Zs,isWindow:js};function Ys(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function Xs(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e(...r)),o}}function Js(e,t){let n,o;return[(...s)=>{const l=t(...s);return n===l||(n=l,o=e(...s)),o},()=>{n=null}]}var Qs={memoizeWithArgsHash:Ys,memoizeOneWithArgsHash:Xs,memoizeOneWithArgsHashAndInvalidation:Js};const{batchUpdates:nn}=Vt,{initializeNode:ei,peekNodeInfo:ti}=be,{graph:ni}=st,{getNextStoreID:oi}=Nt,{DEFAULT_VALUE:ri,recoilValues:In,recoilValuesForKeys:Un}=ce,{AbstractRecoilValue:ai,getRecoilValueAsLoadable:si,setRecoilValue:kn,setUnvalidatedRecoilValue:ii}=_e,{updateRetainCount:_t}=Ve,{setInvalidateMemoizedSnapshot:ci}=mo,{getNextTreeStateVersion:li,makeEmptyStoreState:ui}=uo,{isSSR:di}=$t,{memoizeOneWithArgsHashAndInvalidation:fi}=Qs;class Mt{constructor(t,n){M(this,"_store",void 0),M(this,"_refCount",1),M(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),si(this._store,o))),M(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),M(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const s=this._store.getState().currentTree;return Un(s.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?In.values():o.isInitialized===!0?Un($o([r,a])):pn(In.values(),({key:s})=>!r.has(s)&&!a.has(s))}),M(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),ti(this._store,this._store.getState().currentTree,o))),M(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new on(this,nn);return o(r),r}),M(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new on(this,nn);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:oi(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return j(r.get(o));const a=ni();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw I("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)ei(this._store,o,"get"),_t(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0,this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){di||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!W("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){W("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function Io(e,t,n=!1){const o=e.getState(),r=n?li():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(At(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function hi(e){const t=new Mt(ui());return e!=null?t.map(e):t}const[Dn,Uo]=fi((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:j(o.previousTree);return new Mt(Io(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});ci(Uo);function vi(e,t="latest"){const n=Dn(e,t);return n.isRetained()?n:(Uo(),Dn(e,t))}class on extends Mt{constructor(t,n){super(Io(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),M(this,"_batch",void 0),M(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{_t(a,o.key,1),kn(this.getStore_INTERNAL(),o,r)})}),M(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{_t(r,o.key,1),kn(this.getStore_INTERNAL(),o,ri)})}),M(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();nn(()=>{for(const[a,s]of o.entries())_t(r,a,1),ii(r,new ai(a),s)})}),this._batch=n}}var It={Snapshot:Mt,MutableSnapshot:on,freshSnapshot:hi,cloneSnapshot:vi},pi=It.Snapshot,_i=It.MutableSnapshot,Si=It.freshSnapshot,mi=It.cloneSnapshot,Ut=Object.freeze({__proto__:null,Snapshot:pi,MutableSnapshot:_i,freshSnapshot:Si,cloneSnapshot:mi});function Ri(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var yi=Ri;const{useRef:gi}=Z;function bi(e){const t=gi(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var Bn=bi;const{getNextTreeStateVersion:Ti,makeEmptyStoreState:ko}=uo,{cleanUpNode:wi,getDownstreamNodes:Ei,initializeNode:Ai,setNodeValue:Ni,setUnvalidatedAtomValue_DEPRECATED:Li}=be,{graph:Ci}=st,{cloneGraph:Vi}=st,{getNextStoreID:Do}=Nt,{createMutableSource:Yt,reactMode:Bo}=at,{applyAtomValueWrites:$i}=_e,{releaseScheduledRetainablesNow:Po}=Ve,{freshSnapshot:Mi}=Ut,{useCallback:Ii,useContext:Oo,useEffect:rn,useMemo:Ui,useRef:ki,useState:Di}=Z;function je(){throw I("This component must be used inside a <RecoilRoot> component.")}const xo=Object.freeze({storeID:Do(),getState:je,replaceState:je,getGraph:je,subscribeToTransactions:je,addTransactionMetadata:je});let an=!1;function Pn(e){if(an)throw I("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){W("recoil_memory_managament_2020")&&W("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Po(e);const n=t.currentTree.version,o=Ti();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Vi(j(t.graphsByVersion.get(n))))}}const Fo=Z.createContext({current:xo}),kt=()=>Oo(Fo),zo=Z.createContext(null);function Bi(){return Oo(zo)}function Rn(e,t,n){const o=Ei(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[s,[l,u]]of a)u(n)}}function Wo(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[s,l]of a)l(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!Bo().early||t.suspendedComponentResolvers.size>0)&&(Rn(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Pi(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Wo(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):un("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,W("recoil_memory_managament_2020")&&n==null&&Po(e)}finally{t.commitDepth--}}function Oi({setNotifyBatcherOfChange:e}){const t=kt(),[,n]=Di([]);return e(()=>n({})),rn(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),rn(()=>{Sa.enqueueExecution("Batcher",()=>{Pi(t.current)})}),null}function xi(e,t){const n=ko();return t({set:(o,r)=>{const a=n.currentTree,s=Ni(e,a,o.key,r),l=new Set(s.keys()),u=a.nonvalidatedAtoms.clone();for(const f of l)u.delete(f);n.currentTree={...a,dirtyAtoms:yi(a.dirtyAtoms,l),atomValues:$i(a.atomValues,s),nonvalidatedAtoms:u}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Li(n.currentTree,a,r)})}}),n}function Fi(e){const t=Mi(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let On=0;function zi({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=V=>{const y=r.current.graphsByVersion;if(y.has(V))return j(y.get(V));const E=Ci();return y.set(V,E),E},s=(V,y)=>{if(y==null){const{transactionSubscriptions:E}=p.current.getState(),Y=On++;return E.set(Y,V),{release:()=>{E.delete(Y)}}}else{const{nodeTransactionSubscriptions:E}=p.current.getState();E.has(y)||E.set(y,new Map);const Y=On++;return j(E.get(y)).set(Y,V),{release:()=>{const te=E.get(y);te&&(te.delete(Y),te.size===0&&E.delete(y))}}}},l=V=>{Pn(p.current);for(const y of Object.keys(V))j(p.current.getState().nextTree).transactionMetadata[y]=V[y]},u=V=>{Pn(p.current);const y=j(r.current.nextTree);let E;try{an=!0,E=V(y)}finally{an=!1}E!==y&&(r.current.nextTree=E,Bo().early&&Rn(p.current,r.current,E),j(f.current)())},f=ki(null),v=Ii(V=>{f.current=V},[f]),p=Bn(()=>n??{storeID:Do(),getState:()=>r.current,replaceState:u,getGraph:a,subscribeToTransactions:s,addTransactionMetadata:l});n!=null&&(p.current=n),r=Bn(()=>e!=null?xi(p.current,e):t!=null?Fi(t):ko());const A=Ui(()=>Yt==null?void 0:Yt(r,()=>r.current.currentTree.version),[r]);return rn(()=>{const V=p.current;for(const y of new Set(V.getState().knownAtoms))Ai(V,y,"get");return()=>{for(const y of V.getState().knownAtoms)wi(V,y)}},[p]),Z.createElement(Fo.Provider,{value:p},Z.createElement(zo.Provider,{value:A},Z.createElement(Oi,{setNotifyBatcherOfChange:v}),o))}function Wi(e){const{override:t,...n}=e,o=kt();return t===!1&&o.current!==xo?e.children:Z.createElement(zi,n)}function Gi(){return kt().current.storeID}var ye={RecoilRoot:Wi,useStoreRef:kt,useRecoilMutableSource:Bi,useRecoilStoreID:Gi,notifyComponents_FOR_TESTING:Rn,sendEndOfBatchNotifications_FOR_TESTING:Wo};function Ki(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var Hi=Ki;const{useEffect:qi,useRef:ji}=Z;function Zi(e){const t=ji();return qi(()=>{t.current=e}),t.current}var Go=Zi;const{useStoreRef:Yi}=ye,{SUSPENSE_TIMEOUT_MS:Xi}=Ve,{updateRetainCount:Ze}=Ve,{RetentionZone:Ji}=Lt,{useEffect:Qi,useRef:ec}=Z,{isSSR:xn}=$t;function tc(e){if(W("recoil_memory_managament_2020"))return nc(e)}function nc(e){const n=(Array.isArray(e)?e:[e]).map(s=>s instanceof Ji?s:s.key),o=Yi();Qi(()=>{if(!W("recoil_memory_managament_2020"))return;const s=o.current;if(r.current&&!xn)window.clearTimeout(r.current),r.current=null;else for(const l of n)Ze(s,l,1);return()=>{for(const l of n)Ze(s,l,-1)}},[o,...n]);const r=ec(),a=Go(n);if(!xn&&(a===void 0||!Hi(a,n))){const s=o.current;for(const l of n)Ze(s,l,1);if(a)for(const l of a)Ze(s,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const l of n)Ze(s,l,-1)},Xi)}}var yn=tc;function oc(){return"<component name not available>"}var ct=oc;const{batchUpdates:rc}=Vt,{DEFAULT_VALUE:Ko}=ce,{currentRendererSupportsUseSyncExternalStore:ac,reactMode:Ge,useMutableSource:sc,useSyncExternalStore:ic}=at,{useRecoilMutableSource:cc,useStoreRef:Se}=ye,{AbstractRecoilValue:sn,getRecoilValueAsLoadable:lt,setRecoilValue:Rt,setUnvalidatedRecoilValue:lc,subscribeToRecoilValue:xe}=_e,{useCallback:ie,useEffect:Fe,useMemo:Ho,useRef:nt,useState:gn}=Z,{setByAddingToSet:uc}=ho,{isSSR:dc}=$t;function bn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),dc&&G(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:I(`Invalid value of loadable atom "${t.key}"`)}function fc(){const e=ct(),t=Se(),[,n]=gn([]),o=nt(new Set);o.current=new Set;const r=nt(new Set),a=nt(new Map),s=ie(u=>{const f=a.current.get(u);f&&(f.release(),a.current.delete(u))},[a]),l=ie((u,f)=>{a.current.has(f)&&n([])},[]);return Fe(()=>{const u=t.current;et(o.current,r.current).forEach(f=>{if(a.current.has(f))return;const v=xe(u,new sn(f),A=>l(A,f),e);a.current.set(f,v),u.getState().nextTree?u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(u.getState(),f)}):l(u.getState(),f)}),et(r.current,o.current).forEach(f=>{s(f)}),r.current=o.current}),Fe(()=>{const u=a.current;return et(o.current,new Set(u.keys())).forEach(f=>{const v=xe(t.current,new sn(f),p=>l(p,f),e);u.set(f,v)}),()=>u.forEach((f,v)=>s(v))},[e,t,s,l]),Ho(()=>{function u(y){return E=>{Rt(t.current,y,E)}}function f(y){return()=>Rt(t.current,y,Ko)}function v(y){var E;o.current.has(y.key)||(o.current=uc(o.current,y.key));const Y=t.current.getState();return lt(t.current,y,Ge().early&&(E=Y.nextTree)!==null&&E!==void 0?E:Y.currentTree)}function p(y){const E=v(y);return bn(E,y,t)}function A(y){return[p(y),u(y)]}function V(y){return[v(y),u(y)]}return{getRecoilValue:p,getRecoilValueLoadable:v,getRecoilState:A,getRecoilStateLoadable:V,getSetRecoilState:u,getResetRecoilState:f}},[o,t])}const hc={current:0};function vc(e){const t=Se(),n=ct(),o=ie(()=>{var l;const u=t.current,f=u.getState(),v=Ge().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return{loadable:lt(u,e,v),key:e.key}},[t,e]),r=ie(l=>{let u;return()=>{var f,v;const p=l();return(f=u)!==null&&f!==void 0&&f.loadable.is(p.loadable)&&((v=u)===null||v===void 0?void 0:v.key)===p.key?u:(u=p,p)}},[]),a=Ho(()=>r(o),[o,r]),s=ie(l=>{const u=t.current;return xe(u,e,l,n).release},[t,e,n]);return ic(s,a,a).loadable}function pc(e){const t=Se(),n=ie(()=>{var f;const v=t.current,p=v.getState(),A=Ge().early&&(f=p.nextTree)!==null&&f!==void 0?f:p.currentTree;return lt(v,e,A)},[t,e]),o=ie(()=>n(),[n]),r=ct(),a=ie((f,v)=>{const p=t.current;return xe(p,e,()=>{if(!W("recoil_suppress_rerender_in_callback"))return v();const V=n();u.current.is(V)||v(),u.current=V},r).release},[t,e,r,n]),s=cc();if(s==null)throw I("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const l=sc(s,o,a),u=nt(l);return Fe(()=>{u.current=l}),l}function cn(e){const t=Se(),n=ct(),o=ie(()=>{var u;const f=t.current,v=f.getState(),p=Ge().early&&(u=v.nextTree)!==null&&u!==void 0?u:v.currentTree;return lt(f,e,p)},[t,e]),r=ie(()=>({loadable:o(),key:e.key}),[o,e.key]),a=ie(u=>{const f=r();return u.loadable.is(f.loadable)&&u.key===f.key?u:f},[r]);Fe(()=>{const u=xe(t.current,e,f=>{l(a)},n);return l(a),u.release},[n,e,t,a]);const[s,l]=gn(r);return s.key!==e.key?r().loadable:s.loadable}function _c(e){const t=Se(),[,n]=gn([]),o=ct(),r=ie(()=>{var l;const u=t.current,f=u.getState(),v=Ge().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return lt(u,e,v)},[t,e]),a=r(),s=nt(a);return Fe(()=>{s.current=a}),Fe(()=>{const l=t.current,u=l.getState(),f=xe(l,e,p=>{var A;if(!W("recoil_suppress_rerender_in_callback"))return n([]);const V=r();(A=s.current)!==null&&A!==void 0&&A.is(V)||n(V),s.current=V},o);if(u.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{s.current=null,n([])});else{var v;if(!W("recoil_suppress_rerender_in_callback"))return n([]);const p=r();(v=s.current)!==null&&v!==void 0&&v.is(p)||n(p),s.current=p}return f.release},[o,r,e,t]),a}function Tn(e){return W("recoil_memory_managament_2020")&&yn(e),{TRANSITION_SUPPORT:cn,SYNC_EXTERNAL_STORE:ac()?vc:cn,MUTABLE_SOURCE:pc,LEGACY:_c}[Ge().mode](e)}function qo(e){const t=Se(),n=Tn(e);return bn(n,e,t)}function Dt(e){const t=Se();return ie(n=>{Rt(t.current,e,n)},[t,e])}function Sc(e){const t=Se();return ie(()=>{Rt(t.current,e,Ko)},[t,e])}function mc(e){return[qo(e),Dt(e)]}function Rc(e){return[Tn(e),Dt(e)]}function yc(){const e=Se();return(t,n={})=>{rc(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>lc(e.current,new sn(r),o))})}}function jo(e){return W("recoil_memory_managament_2020")&&yn(e),cn(e)}function Zo(e){const t=Se(),n=jo(e);return bn(n,e,t)}function gc(e){return[Zo(e),Dt(e)]}var bc={recoilComponentGetRecoilValueCount_FOR_TESTING:hc,useRecoilInterface:fc,useRecoilState:mc,useRecoilStateLoadable:Rc,useRecoilValue:qo,useRecoilValueLoadable:Tn,useResetRecoilState:Sc,useSetRecoilState:Dt,useSetUnvalidatedAtomValues:yc,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:jo,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Zo,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:gc};function Tc(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var wc=Tc;function Ec(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n}var Ac=Ec;function Nc(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var Lc=Nc;const{batchUpdates:Cc}=Vt,{DEFAULT_VALUE:Vc,getNode:Yo,nodes:$c}=ce,{useStoreRef:wn}=ye,{AbstractRecoilValue:Mc,setRecoilValueLoadable:Ic}=_e,{SUSPENSE_TIMEOUT_MS:Uc}=Ve,{cloneSnapshot:yt}=Ut,{useCallback:Bt,useEffect:Xo,useRef:Fn,useState:kc}=Z,{isSSR:zn}=$t;function Pt(e){const t=wn();Xo(()=>t.current.subscribeToTransactions(e).release,[e,t])}function Wn(e){const t=e.atomValues.toMap(),n=mt(wc(t,(o,r)=>{const s=Yo(r).persistence_UNSTABLE;return s!=null&&s.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return Lc(e.nonvalidatedAtoms.toMap(),n)}function Dc(e){Pt(Bt(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=Wn(o),a=Wn(n),s=mt($c,u=>{var f,v,p,A;return{persistence_UNSTABLE:{type:(f=(v=u.persistence_UNSTABLE)===null||v===void 0?void 0:v.type)!==null&&f!==void 0?f:"none",backButton:(p=(A=u.persistence_UNSTABLE)===null||A===void 0?void 0:A.backButton)!==null&&p!==void 0?p:!1}}}),l=Ac(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function Bc(e){Pt(Bt(t=>{const n=yt(t,"latest"),o=yt(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function Pc(){const e=wn(),[t,n]=kc(()=>yt(e.current)),o=Go(t),r=Fn(),a=Fn();if(Pt(Bt(l=>n(yt(l)),[])),Xo(()=>{const l=t.retain();if(r.current&&!zn){var u;window.clearTimeout(r.current),r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null}return()=>{window.setTimeout(l,10)}},[t]),o!==t&&!zn){if(r.current){var s;window.clearTimeout(r.current),r.current=null,(s=a.current)===null||s===void 0||s.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var l;r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null},Uc)}return t}function Jo(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Cc(()=>{const s=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const v of f){var l,u;((l=r.atomValues.get(v))===null||l===void 0?void 0:l.contents)!==((u=a.atomValues.get(v))===null||u===void 0?void 0:u.contents)&&Yo(v).shouldRestoreFromSnapshots&&s.add(v)}s.forEach(f=>{Ic(e,new Mc(f),a.atomValues.has(f)?j(a.atomValues.get(f)):Vc)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function Oc(){const e=wn();return Bt(t=>Jo(e.current,t),[e])}var Qo={useRecoilSnapshot:Pc,gotoSnapshot:Jo,useGotoRecoilSnapshot:Oc,useRecoilTransactionObserver:Bc,useTransactionObservation_DEPRECATED:Dc,useTransactionSubscription_DEPRECATED:Pt};const{peekNodeInfo:xc}=be,{useStoreRef:Fc}=ye;function zc(){const e=Fc();return({key:t})=>xc(e.current,e.current.getState().currentTree,t)}var Wc=zc;const{reactMode:Gc}=at,{RecoilRoot:Kc,useStoreRef:Hc}=ye,{useMemo:qc}=Z;function jc(){Gc().mode==="MUTABLE_SOURCE"&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=Hc().current;return qc(()=>{function t({children:n}){return Z.createElement(Kc,{store_INTERNAL:e},n)}return t},[e])}var Zc=jc;const{loadableWithValue:Yc}=rt,{initializeNode:Xc}=be,{DEFAULT_VALUE:Jc,getNode:Qc}=ce,{copyTreeState:el,getRecoilValueAsLoadable:tl,invalidateDownstreams:nl,writeLoadableToTreeState:ol}=_e;function Gn(e){return Qc(e.key).nodeType==="atom"}class rl{constructor(t,n){M(this,"_store",void 0),M(this,"_treeState",void 0),M(this,"_changes",void 0),M(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!Gn(o))throw I("Reading selectors within atomicUpdate is not supported");const r=tl(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:I(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),M(this,"set",(o,r)=>{if(!Gn(o))throw I("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else Xc(this._store,o.key,"set"),this._changes.set(o.key,r)}),M(this,"reset",o=>{this.set(o,Jc)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=el(this._treeState);for(const[n,o]of this._changes)ol(t,n,Yc(o));return nl(this._store,t),t}}function al(e){return t=>{e.replaceState(n=>{const o=new rl(e,n);return t(o),o.newTreeState_INTERNAL()})}}var sl={atomicUpdater:al},il=sl.atomicUpdater,er=Object.freeze({__proto__:null,atomicUpdater:il});function cl(e,t){if(!e)throw new Error(t)}var ll=cl,Qe=ll;const{atomicUpdater:ul}=er,{batchUpdates:dl}=Vt,{DEFAULT_VALUE:fl}=ce,{useStoreRef:hl}=ye,{refreshRecoilValue:vl,setRecoilValue:Kn}=_e,{cloneSnapshot:pl}=Ut,{gotoSnapshot:_l}=Qo,{useCallback:Sl}=Z;class tr{}const ml=new tr;function nr(e,t,n,o){let r=ml,a;if(dl(()=>{const l="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw I(l);const u=vo({...o??{},set:(v,p)=>Kn(e,v,p),reset:v=>Kn(e,v,fl),refresh:v=>vl(e,v),gotoSnapshot:v=>_l(e,v),transact_UNSTABLE:v=>ul(e)(v)},{snapshot:()=>{const v=pl(e);return a=v.retain(),v}}),f=t(u);if(typeof f!="function")throw I(l);r=f(...n)}),r instanceof tr&&Qe(!1),G(r))r=r.finally(()=>{var l;(l=a)===null||l===void 0||l()});else{var s;(s=a)===null||s===void 0||s()}return r}function Rl(e,t){const n=hl();return Sl((...o)=>nr(n.current,e,o),t!=null?[...t,n]:void 0)}var or={recoilCallback:nr,useRecoilCallback:Rl};const{useStoreRef:yl}=ye,{refreshRecoilValue:gl}=_e,{useCallback:bl}=Z;function Tl(e){const t=yl();return bl(()=>{const n=t.current;gl(n,e)},[e,t])}var wl=Tl;const{atomicUpdater:El}=er,{useStoreRef:Al}=ye,{useMemo:Nl}=Z;function Ll(e,t){const n=Al();return Nl(()=>(...o)=>{El(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var Cl=Ll;class Vl{constructor(t){M(this,"value",void 0),this.value=t}}var $l={WrappedValue:Vl},Ml=$l.WrappedValue,rr=Object.freeze({__proto__:null,WrappedValue:Ml});const{isFastRefreshEnabled:Il}=at;class Hn extends Error{}class Ul{constructor(t){var n,o,r;M(this,"_name",void 0),M(this,"_numLeafs",void 0),M(this,"_root",void 0),M(this,"_onHit",void 0),M(this,"_onSet",void 0),M(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,s,l,u;let f,v;for(const[Y,te]of t){var p,A,V;const w=this._root;if((w==null?void 0:w.type)==="leaf")throw this.invalidCacheError();const B=f;if(f=B?B.branches.get(v):w,f=(p=f)!==null&&p!==void 0?p:{type:"branch",nodeKey:Y,parent:B,branches:new Map,branchKey:v},f.type!=="branch"||f.nodeKey!==Y)throw this.invalidCacheError();B==null||B.branches.set(v,f),o==null||(A=o.onNodeVisit)===null||A===void 0||A.call(o,f),v=this._mapNodeValue(te),this._root=(V=this._root)!==null&&V!==void 0?V:f}const y=f?(a=f)===null||a===void 0?void 0:a.branches.get(v):this._root;if(y!=null&&(y.type!=="leaf"||y.branchKey!==v))throw this.invalidCacheError();const E={type:"leaf",value:n,parent:f,branchKey:v};(s=f)===null||s===void 0||s.branches.set(v,E),this._root=(l=this._root)!==null&&l!==void 0?l:E,this._numLeafs++,this._onSet(E),o==null||(u=o.onNodeVisit)===null||u===void 0||u.call(o,E)};try{r()}catch(a){if(a instanceof Hn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){const t=Il()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw un(t+(this._name!=null?` - ${this._name}`:"")),new Hn}}var kl={TreeCache:Ul},Dl=kl.TreeCache,ar=Object.freeze({__proto__:null,TreeCache:Dl});class Bl{constructor(t){var n;M(this,"_maxSize",void 0),M(this,"_size",void 0),M(this,"_head",void 0),M(this,"_tail",void 0),M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),s={key:t,right:a,left:null,value:n};a?a.left=s:this._tail=s,this._map.set(o,s),this._head=s,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=j(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var Pl={LRUCache:Bl},Ol=Pl.LRUCache,sr=Object.freeze({__proto__:null,LRUCache:Ol});const{LRUCache:xl}=sr,{TreeCache:Fl}=ar;function zl({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new xl({maxSize:t}),r=new Fl({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const s=o.tail();o.set(a,!0),s&&r.size()>t&&r.delete(s.key)}});return r}var qn=zl;function pe(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw I("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(G(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>pe(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return pe(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,s]of e)r[typeof a=="string"?a:pe(a,t)]=s;return pe(r,t,n)}return e instanceof Set?pe(Array.from(e).sort((r,a)=>pe(r,t).localeCompare(pe(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?pe(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${pe(r,t)}:${pe(e[r],t,r)}`).join(",")}}`}function Wl(e,t={allowFunctions:!1}){return pe(e,t)}var Ot=Wl;const{TreeCache:Gl}=ar,dt={equality:"reference",eviction:"keep-all",maxSize:1/0};function Kl({equality:e=dt.equality,eviction:t=dt.eviction,maxSize:n=dt.maxSize}=dt,o){const r=Hl(e);return ql(t,n,r,o)}function Hl(e){switch(e){case"reference":return t=>t;case"value":return t=>Ot(t)}throw I(`Unrecognized equality policy ${e}`)}function ql(e,t,n,o){switch(e){case"keep-all":return new Gl({name:o,mapNodeValue:n});case"lru":return qn({name:o,maxSize:j(t),mapNodeValue:n});case"most-recent":return qn({name:o,maxSize:1,mapNodeValue:n})}throw I(`Unrecognized eviction policy ${e}`)}var jl=Kl;function Zl(e){return()=>null}var Yl={startPerfBlock:Zl};const{isLoadable:Xl,loadableWithError:ft,loadableWithPromise:Jl,loadableWithValue:Xt}=rt,{WrappedValue:ir}=rr,{getNodeLoadable:ht,peekNodeLoadable:Ql,setNodeValue:eu}=be,{saveDepsToStore:tu}=st,{DEFAULT_VALUE:nu,getConfigDeletionHandler:ou,getNode:ru,registerNode:jn}=ce,{isRecoilValue:au}=Oe,{markRecoilValueModified:Zn}=_e,{retainedByOptionWithDefault:su}=Ve,{recoilCallback:iu}=or,{startPerfBlock:cu}=Yl;class cr{}const Ye=new cr,Xe=[],vt=new Map,lu=(()=>{let e=0;return()=>e++})();function lr(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,s=new Set,l=jl(r??{equality:"reference",eviction:"keep-all"},n),u=su(e.retainedBy_UNSTABLE),f=new Map;let v=0;function p(){return!W("recoil_memory_managament_2020")||v>0}function A(d){return d.getState().knownSelectors.add(n),v++,()=>{v--}}function V(){return ou(n)!==void 0&&!p()}function y(d,_,S,$,b){Me(_,$,b),E(d,S)}function E(d,_){le(d,_)&&oe(d),te(_,!0)}function Y(d,_){le(d,_)&&(j(x(d)).stateVersions.clear(),te(_,!1))}function te(d,_){const S=vt.get(d);if(S!=null){for(const $ of S)Zn($,j(t));_&&vt.delete(d)}}function w(d,_){let S=vt.get(_);S==null&&vt.set(_,S=new Set),S.add(d)}function B(d,_,S,$,b,D){return _.then(k=>{if(!p())throw oe(d),Ye;const T=Xt(k);return y(d,S,b,T,$),k}).catch(k=>{if(!p())throw oe(d),Ye;if(G(k))return Q(d,k,S,$,b,D);const T=ft(k);throw y(d,S,b,T,$),k})}function Q(d,_,S,$,b,D){return _.then(k=>{if(!p())throw oe(d),Ye;D.loadingDepKey!=null&&D.loadingDepPromise===_?S.atomValues.set(D.loadingDepKey,Xt(k)):d.getState().knownSelectors.forEach(F=>{S.atomValues.delete(F)});const T=X(d,S);if(T&&T.state!=="loading"){if((le(d,b)||x(d)==null)&&E(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!le(d,b)){const F=me(d,S);if(F!=null)return F.loadingLoadable.contents}const[H,ee]=K(d,S,b);if(H.state!=="loading"&&y(d,S,b,H,ee),H.state==="hasError")throw H.contents;return H.contents}).catch(k=>{if(k instanceof cr)throw Ye;if(!p())throw oe(d),Ye;const T=ft(k);throw y(d,S,b,T,$),k})}function z(d,_,S,$){var b,D,k,T;if(le(d,$)||_.version===((b=d.getState())===null||b===void 0||(D=b.currentTree)===null||D===void 0?void 0:D.version)||_.version===((k=d.getState())===null||k===void 0||(T=k.nextTree)===null||T===void 0?void 0:T.version)){var H,ee,F;tu(n,S,d,(H=(ee=d.getState())===null||ee===void 0||(F=ee.nextTree)===null||F===void 0?void 0:F.version)!==null&&H!==void 0?H:d.getState().currentTree.version)}for(const J of S)s.add(J)}function K(d,_,S){const $=cu(n);let b=!0,D=!0;const k=()=>{$(),D=!1};let T,H=!1,ee;const F={loadingDepKey:null,loadingDepPromise:null},J=new Map;function he({key:de}){const ue=ht(d,_,de);switch(J.set(de,ue),b||(z(d,_,new Set(J.keys()),S),Y(d,S)),ue.state){case"hasValue":return ue.contents;case"hasError":throw ue.contents;case"loading":throw F.loadingDepKey=de,F.loadingDepPromise=ue.contents,ue.contents}throw I("Invalid Loadable state")}const Ee=de=>(...ue)=>{if(D)throw I("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&Qe(!1),iu(d,de,ue,{node:t})};try{T=o({get:he,getCallback:Ee}),T=au(T)?he(T):T,Xl(T)&&(T.state==="hasError"&&(H=!0),T=T.contents),G(T)?T=B(d,T,_,J,S,F).finally(k):k(),T=T instanceof ir?T.value:T}catch(de){T=de,G(T)?T=Q(d,T,_,J,S,F).finally(k):(H=!0,k())}return H?ee=ft(T):G(T)?ee=Jl(T):ee=Xt(T),b=!1,we(d,S,J),z(d,_,new Set(J.keys()),S),[ee,J]}function X(d,_){let S=_.atomValues.get(n);if(S!=null)return S;const $=new Set;try{S=l.get(D=>(typeof D!="string"&&Qe(!1),ht(d,_,D).contents),{onNodeVisit:D=>{D.type==="branch"&&D.nodeKey!==n&&$.add(D.nodeKey)}})}catch(D){throw I(`Problem with cache lookup for selector "${n}": ${D.message}`)}if(S){var b;_.atomValues.set(n,S),z(d,_,$,(b=x(d))===null||b===void 0?void 0:b.executionID)}return S}function ae(d,_){const S=X(d,_);if(S!=null)return oe(d),S;const $=me(d,_);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&w(d,$.executionID),$.loadingLoadable}const D=lu(),[k,T]=K(d,_,D);return k.state==="loading"?(re(d,D,k,T,_),w(d,D)):(oe(d),Me(_,k,T)),k}function me(d,_){const S=$o([f.has(d)?[j(f.get(d))]:[],At(pn(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(const[D,k]of b)if(!ht(d,_,D).is(k))return!0;return!1}for(const b of S){if(b.stateVersions.get(_.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(_.version,!0),b;b.stateVersions.set(_.version,!1)}}function x(d){return f.get(d)}function re(d,_,S,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:_,loadingLoadable:S,stateVersions:new Map([[b.version,!0]])})}function we(d,_,S){if(le(d,_)){const $=x(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=S)}}function oe(d){f.delete(d)}function le(d,_){var S;return _===((S=x(d))===null||S===void 0?void 0:S.executionID)}function $e(d){return Array.from(d.entries()).map(([_,S])=>[_,S.contents])}function Me(d,_,S){d.atomValues.set(n,_);try{l.set($e(S),_)}catch($){throw I(`Problem with setting cache for selector "${n}": ${$.message}`)}}function Re(d){if(Xe.includes(n)){const _=`Recoil selector has circular dependencies: ${Xe.slice(Xe.indexOf(n)).join(" → ")}`;return ft(I(_))}Xe.push(n);try{return d()}finally{Xe.pop()}}function Ie(d,_){const S=_.atomValues.get(n);return S??l.get($=>{var b;return typeof $!="string"&&Qe(!1),(b=Ql(d,_,$))===null||b===void 0?void 0:b.contents})}function Ue(d,_){return Re(()=>ae(d,_))}function P(d){d.atomValues.delete(n)}function O(d,_){t==null&&Qe(!1);for(const $ of s){var S;const b=ru($);(S=b.clearCache)===null||S===void 0||S.call(b,d,_)}s.clear(),P(_),l.clear(),Zn(d,t)}return a!=null?t=jn({key:n,nodeType:"selector",peek:Ie,get:Ue,set:(_,S,$)=>{let b=!1;const D=new Map;function k({key:F}){if(b)throw I("Recoil: Async selector sets are not currently supported.");const J=ht(_,S,F);if(J.state==="hasValue")return J.contents;if(J.state==="loading"){const he=`Getting value of asynchronous atom or selector "${F}" in a pending state while setting selector "${n}" is not yet supported.`;throw I(he)}else throw J.contents}function T(F,J){if(b)throw I("Recoil: Async selector sets are not currently supported.");const he=typeof J=="function"?J(k(F)):J;eu(_,S,F.key,he).forEach((de,ue)=>D.set(ue,de))}function H(F){T(F,nu)}const ee=a({set:T,get:k,reset:H},$);if(ee!==void 0)throw G(ee)?I("Recoil: Async selector sets are not currently supported."):I("Recoil: selector set should be a void function.");return b=!0,D},init:A,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:V,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u}):t=jn({key:n,nodeType:"selector",peek:Ie,get:Ue,init:A,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:V,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}lr.value=e=>new ir(e);var ze=lr;const{isLoadable:uu,loadableWithError:Jt,loadableWithPromise:Qt,loadableWithValue:De}=rt,{WrappedValue:ur}=rr,{peekNodeInfo:du}=be,{DEFAULT_VALUE:Ae,DefaultValue:ge,getConfigDeletionHandler:dr,registerNode:fu,setConfigDeletionHandler:hu}=ce,{isRecoilValue:vu}=Oe,{getRecoilValueAsLoadable:pu,markRecoilValueModified:_u,setRecoilValue:Yn,setRecoilValueLoadable:Su}=_e,{retainedByOptionWithDefault:mu}=Ve,Je=e=>e instanceof ur?e.value:e;function Ru(e){const{key:t,persistence_UNSTABLE:n}=e,o=mu(e.retainedBy_UNSTABLE);let r=0;function a(w){return Qt(w.then(B=>(s=De(B),B)).catch(B=>{throw s=Jt(B),B}))}let s=G(e.default)?a(e.default):uu(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:De(Je(e.default));s.contents;let l;const u=new Map;function f(w){return w}function v(w,B){const Q=B.then(z=>{var K,X;return((X=((K=w.getState().nextTree)!==null&&K!==void 0?K:w.getState().currentTree).atomValues.get(t))===null||X===void 0?void 0:X.contents)===Q&&Yn(w,te,z),z}).catch(z=>{var K,X;throw((X=((K=w.getState().nextTree)!==null&&K!==void 0?K:w.getState().currentTree).atomValues.get(t))===null||X===void 0?void 0:X.contents)===Q&&Su(w,te,Jt(z)),z});return Q}function p(w,B,Q){var z;r++;const K=()=>{var x;r--,(x=u.get(w))===null||x===void 0||x.forEach(re=>re()),u.delete(w)};if(w.getState().knownAtoms.add(t),s.state==="loading"){const x=()=>{var re;((re=w.getState().nextTree)!==null&&re!==void 0?re:w.getState().currentTree).atomValues.has(t)||_u(w,te)};s.contents.finally(x)}const X=(z=e.effects)!==null&&z!==void 0?z:e.effects_UNSTABLE;if(X!=null){let le=function(P){if(re&&P.key===t){const O=x;return O instanceof ge?A(w,B):G(O)?Qt(O.then(d=>d instanceof ge?s.toPromise():d)):De(O)}return pu(w,P)},$e=function(P){return le(P).toPromise()},Me=function(P){var O;const d=du(w,(O=w.getState().nextTree)!==null&&O!==void 0?O:w.getState().currentTree,P.key);return re&&P.key===t&&!(x instanceof ge)?{...d,isSet:!0,loadable:le(P)}:d},x=Ae,re=!0,we=!1,oe=null;const Re=P=>O=>{if(re){const d=le(te),_=d.state==="hasValue"?d.contents:Ae;x=typeof O=="function"?O(_):O,G(x)&&(x=x.then(S=>(oe={effect:P,value:S},S)))}else{if(G(O))throw I("Setting atoms to async values is not implemented.");typeof O!="function"&&(oe={effect:P,value:Je(O)}),Yn(w,te,typeof O=="function"?d=>{const _=Je(O(d));return oe={effect:P,value:_},_}:Je(O))}},Ie=P=>()=>Re(P)(Ae),Ue=P=>O=>{var d;const{release:_}=w.subscribeToTransactions(S=>{var $;let{currentTree:b,previousTree:D}=S.getState();D||(D=b);const k=($=b.atomValues.get(t))!==null&&$!==void 0?$:s;if(k.state==="hasValue"){var T,H,ee,F;const J=k.contents,he=(T=D.atomValues.get(t))!==null&&T!==void 0?T:s,Ee=he.state==="hasValue"?he.contents:Ae;((H=oe)===null||H===void 0?void 0:H.effect)!==P||((ee=oe)===null||ee===void 0?void 0:ee.value)!==J?O(J,Ee,!b.atomValues.has(t)):((F=oe)===null||F===void 0?void 0:F.effect)===P&&(oe=null)}},t);u.set(w,[...(d=u.get(w))!==null&&d!==void 0?d:[],_])};for(const P of X)try{const O=P({node:te,storeID:w.storeID,parentStoreID_UNSTABLE:w.parentStoreID,trigger:Q,setSelf:Re(P),resetSelf:Ie(P),onSet:Ue(P),getPromise:$e,getLoadable:le,getInfo_UNSTABLE:Me});if(O!=null){var ae;u.set(w,[...(ae=u.get(w))!==null&&ae!==void 0?ae:[],O])}}catch(O){x=O,we=!0}if(re=!1,!(x instanceof ge)){var me;const P=we?Jt(x):G(x)?Qt(v(w,x)):De(Je(x));P.contents,B.atomValues.set(t,P),(me=w.getState().nextTree)===null||me===void 0||me.atomValues.set(t,P)}}return K}function A(w,B){var Q,z;return(Q=(z=B.atomValues.get(t))!==null&&z!==void 0?z:l)!==null&&Q!==void 0?Q:s}function V(w,B){if(B.atomValues.has(t))return j(B.atomValues.get(t));if(B.nonvalidatedAtoms.has(t)){if(l!=null)return l;if(n==null)return s;const Q=B.nonvalidatedAtoms.get(t),z=n.validator(Q,Ae);return l=z instanceof ge?s:De(z),l}else return s}function y(){l=void 0}function E(w,B,Q){if(B.atomValues.has(t)){const z=j(B.atomValues.get(t));if(z.state==="hasValue"&&Q===z.contents)return new Map}else if(!B.nonvalidatedAtoms.has(t)&&Q instanceof ge)return new Map;return l=void 0,new Map().set(t,De(Q))}function Y(){return dr(t)!==void 0&&r<=0}const te=fu({key:t,nodeType:"atom",peek:A,get:V,set:E,init:p,invalidate:y,shouldDeleteConfigOnRelease:Y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return te}function En(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return vu(n)?yu({...t,default:n}):Ru({...t,default:n})}function yu(e){const t=En({...e,default:Ae,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof ge?o:j(e.persistence_UNSTABLE).validator(o,Ae)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=ze({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof ge?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return hu(n.key,dr(e.key)),n}En.value=e=>new ur(e);var fr=En;class gu{constructor(t){var n;M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var bu={MapCache:gu},Tu=bu.MapCache,wu=Object.freeze({__proto__:null,MapCache:Tu});const{LRUCache:Xn}=sr,{MapCache:Eu}=wu,pt={equality:"reference",eviction:"none",maxSize:1/0};function Au({equality:e=pt.equality,eviction:t=pt.eviction,maxSize:n=pt.maxSize}=pt){const o=Nu(e);return Lu(t,n,o)}function Nu(e){switch(e){case"reference":return t=>t;case"value":return t=>Ot(t)}throw I(`Unrecognized equality policy ${e}`)}function Lu(e,t,n){switch(e){case"keep-all":return new Eu({mapKey:n});case"lru":return new Xn({mapKey:n,maxSize:j(t)});case"most-recent":return new Xn({mapKey:n,maxSize:1})}throw I(`Unrecognized eviction policy ${e}`)}var hr=Au;const{setConfigDeletionHandler:Cu}=ce;function Vu(e){var t,n;const o=hr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,s;const l=o.get(r);if(l!=null)return l;const{cachePolicyForParams_UNSTABLE:u,...f}=e,v="default"in e?e.default:new Promise(()=>{}),p=fr({...f,key:`${e.key}__${(a=Ot(r))!==null&&a!==void 0?a:"void"}`,default:typeof v=="function"?v(r):v,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(s=e.effects)!==null&&s!==void 0?s:e.effects_UNSTABLE});return o.set(r,p),Cu(p.key,()=>{o.delete(r)}),p}}var $u=Vu;const{setConfigDeletionHandler:Mu}=ce;let Iu=0;function Uu(e){var t,n;const o=hr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let s;try{s=o.get(r)}catch(A){throw I(`Problem with cache lookup for selector ${e.key}: ${A.message}`)}if(s!=null)return s;const l=`${e.key}__selectorFamily/${(a=Ot(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${Iu++}`,u=A=>e.get(r)(A),f=e.cachePolicy_UNSTABLE,v=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let p;if(e.set!=null){const A=e.set;p=ze({key:l,get:u,set:(y,E)=>A(r)(y,E),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v})}else p=ze({key:l,get:u,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v});return o.set(r,p),Mu(p.key,()=>{o.delete(r)}),p}}var Te=Uu;const ku=Te({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Du(e){return ku(e)}var Bu=Du;const Pu=Te({key:"__error",get:e=>()=>{throw I(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Ou(e){return Pu(e)}var xu=Ou;function Fu(e){return e}var zu=Fu;const{loadableWithError:vr,loadableWithPromise:pr,loadableWithValue:_r}=rt;function xt(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(s){o[r]=s}return[n,o]}function Wu(e){return e!=null&&!G(e)}function Ft(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function ln(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Be(e,t,n){const o=n.map((r,a)=>r==null?_r(t[a]):G(r)?pr(r):vr(r));return ln(e,o)}function Gu(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}const Ku=Te({key:"__waitForNone",get:e=>({get:t})=>{const n=Ft(e),[o,r]=xt(t,n);return Be(e,o,r)},dangerouslyAllowMutability:!0}),Hu=Te({key:"__waitForAny",get:e=>({get:t})=>{const n=Ft(e),[o,r]=xt(t,n);return r.some(a=>!G(a))?Be(e,o,r):new Promise(a=>{for(const[s,l]of r.entries())G(l)&&l.then(u=>{o[s]=u,r[s]=void 0,a(Be(e,o,r))}).catch(u=>{r[s]=u,a(Be(e,o,r))})})},dangerouslyAllowMutability:!0}),qu=Te({key:"__waitForAll",get:e=>({get:t})=>{const n=Ft(e),[o,r]=xt(t,n);if(r.every(s=>s==null))return ln(e,o);const a=r.find(Wu);if(a!=null)throw a;return Promise.all(r).then(s=>ln(e,Gu(o,s)))},dangerouslyAllowMutability:!0}),ju=Te({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Ft(e),[o,r]=xt(t,n);return r.every(a=>!G(a))?Be(e,o,r):Promise.all(r.map((a,s)=>G(a)?a.then(l=>{o[s]=l,r[s]=void 0}).catch(l=>{o[s]=void 0,r[s]=l}):null)).then(()=>Be(e,o,r))},dangerouslyAllowMutability:!0}),Zu=Te({key:"__noWait",get:e=>({get:t})=>{try{return ze.value(_r(t(e)))}catch(n){return ze.value(G(n)?pr(n):vr(n))}},dangerouslyAllowMutability:!0});var Yu={waitForNone:Ku,waitForAny:Hu,waitForAll:qu,waitForAllSettled:ju,noWait:Zu};const{RecoilLoadable:Xu}=rt,{DefaultValue:Ju}=ce,{RecoilRoot:Qu,useRecoilStoreID:ed}=ye,{isRecoilValue:td}=Oe,{retentionZone:nd}=Lt,{freshSnapshot:od}=Ut,{useRecoilState:rd,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ad,useRecoilStateLoadable:sd,useRecoilValue:id,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:cd,useRecoilValueLoadable:ld,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ud,useResetRecoilState:dd,useSetRecoilState:fd}=bc,{useGotoRecoilSnapshot:hd,useRecoilSnapshot:vd,useRecoilTransactionObserver:pd}=Qo,{useRecoilCallback:_d}=or,{noWait:Sd,waitForAll:md,waitForAllSettled:Rd,waitForAny:yd,waitForNone:gd}=Yu;var Ke={DefaultValue:Ju,isRecoilValue:td,RecoilLoadable:Xu,RecoilEnv:We,RecoilRoot:Qu,useRecoilStoreID:ed,useRecoilBridgeAcrossReactRoots_UNSTABLE:Zc,atom:fr,selector:ze,atomFamily:$u,selectorFamily:Te,constSelector:Bu,errorSelector:xu,readOnlySelector:zu,noWait:Sd,waitForNone:gd,waitForAny:yd,waitForAll:md,waitForAllSettled:Rd,useRecoilValue:id,useRecoilValueLoadable:ld,useRecoilState:rd,useRecoilStateLoadable:sd,useSetRecoilState:fd,useResetRecoilState:dd,useGetRecoilValueInfo_UNSTABLE:Wc,useRecoilRefresher_UNSTABLE:wl,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ud,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:cd,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ad,useRecoilCallback:_d,useRecoilTransaction_UNSTABLE:Cl,useGotoRecoilSnapshot:hd,useRecoilSnapshot:vd,useRecoilTransactionObserver_UNSTABLE:pd,snapshot_UNSTABLE:od,useRetain:yn,retentionZone:nd},Nd=Ke.RecoilRoot,Sr=Ke.atom,bd=Ke.selector,Td=Ke.useRecoilValue,mr=Ke.useRecoilState,Rr=Ke.useSetRecoilState;const zt=Sr({key:"currentNotificationState",default:{message:void 0,type:void 0}}),yr=Sr({key:"pendingNotificationsState",default:{pending:[]}}),Ld=bd({key:"isNotificationVisibleState",get:({get:e})=>!!e(zt).message}),wd=()=>{const e=Rr(zt);return gt.useCallback((n,o)=>{e({message:n,type:o})},[e])},Ed=()=>{const e=Rr(zt);return gt.useCallback(()=>{e({message:void 0,type:void 0})},[e])},Cd=()=>{const[e,t]=mr(yr),n=wd();return gt.useCallback(()=>{if(!e.pending.length)return;const r=e.pending[0];t(a=>({...a,pending:a.pending.slice(1)})),n(r.message,r.type)},[n,e,t])},Vd=()=>{const[e,t]=mr(yr),n=Td(zt),o=Ed(),r=gt.useCallback((f,v)=>{const p=e.pending.at(-1);(p==null?void 0:p.message)===f||(n==null?void 0:n.message)===f||t(A=>({...A,pending:[...A.pending,{message:f,type:v}]}))},[e,t,n]);return{hideCurrentNotification:o,success:f=>r(f,"success"),info:f=>r(f,"info"),warning:f=>r(f,"warning"),error:f=>r(f,"error")}};export{Td as R,Ed as a,Cd as b,Nd as c,Ld as i,zt as n,yr as p,Vd as u};
//# sourceMappingURL=hooks-d288bee1.js.map
