{"version":3,"file":"TextMeasurerWebWorker-0ade84ba.js","sources":["../src/core/utils/assertions.ts","../src/core/utils/strings.ts","../src/fonts/constants.ts","../src/fonts/utils.ts","../src/fonts/registry/dependencies/awaiters/BaseFontAwaiter.ts","../src/fonts/registry/dependencies/awaiters/FontFaceFontAwaiter.ts","../src/fonts/registry/dependencies/observers/WorkerAdderFontObserver.ts","../src/fonts/registry/FontRegistry.ts","../src/text-measuring/measurers/BaseTextMeasurer.ts","../src/text-measuring/measurers/CanvasTextMeasurer.ts","../src/webworkers/utils.ts","../src/webworkers/messages.ts","../src/webworkers/workers/worker-utils.ts","../src/webworkers/workers/text-measuring/TextMeasurerWebWorker.ts"],"sourcesContent":["export function isDefined<T>(\n  value: T | undefined | null,\n  errorMessage: string,\n): asserts value is T {\n  if (value === undefined || value === null) {\n    throw new Error(errorMessage);\n  }\n}\n","/**\n * According to copilot, this is a good enough way to hash a string that is also compatible with web workers.\n */\nexport function hashString(str: string): string {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash.toString();\n}\n","export const DEFAULT_FONT_SIZE = 14 as const;\n","import { hashString } from '../core/utils/strings';\n\nimport { DEFAULT_FONT_SIZE } from './constants';\nimport { PredefinedFont, FontRegistrationData } from './types';\n\nexport function buildCssStringForFont(\n  fontName: string,\n  isBold: boolean,\n  isItalic: boolean,\n  fontSize: number = DEFAULT_FONT_SIZE,\n) {\n  let fontString = '';\n\n  if (isBold) {\n    fontString += 'bold ';\n  }\n\n  if (isItalic) {\n    fontString += 'italic ';\n  }\n\n  fontString += `${fontSize}px \"${fontName}\"`;\n\n  return fontString;\n}\n\nexport function buildCssStringForFontWithoutSize(\n  fontName: string,\n  isBold: boolean,\n  isItalic: boolean,\n) {\n  let fontString = '';\n\n  if (isBold) {\n    fontString += 'bold ';\n  }\n\n  if (isItalic) {\n    fontString += 'italic ';\n  }\n\n  fontString += `\"${fontName}\"`;\n\n  return fontString;\n}\n\nexport function convertPredefinedFontToFontRegistrationData(\n  predefinedFont: PredefinedFont,\n): FontRegistrationData {\n  return {\n    font: predefinedFont.name,\n    displayName: predefinedFont.display,\n    url: predefinedFont.url,\n    isBold: predefinedFont.bold,\n    isItalic: predefinedFont.italic,\n    isCustom: false,\n  };\n}\n\nexport function buildFontMetadata(isBold: boolean, isItalic: boolean) {\n  const weight = isBold ? 'bold' : 'normal';\n  const style = isItalic ? 'italic' : 'normal';\n\n  return {\n    weight,\n    style,\n  };\n}\n\nexport function buildFontFace(\n  font: string,\n  url: string,\n  isBold: boolean,\n  isItalic: boolean,\n) {\n  const metadata = buildFontMetadata(isBold, isItalic);\n  return new FontFace(font, `url(${url})`, metadata);\n}\n\nexport function generateIdForFontRegistrationData(\n  fontRegistrationData: Omit<\n    FontRegistrationData,\n    'isCustom' | 'displayName'\n  > & {\n    displayName?: string;\n  },\n) {\n  const { font, displayName, isBold, isItalic, url } = fontRegistrationData;\n  const weight = isBold ? 'bold' : 'normal';\n  const style = isItalic ? 'italic' : 'normal';\n  // We hash the display name to be compatible with storybook Controls and URL params\n  const hashedDisplayName = displayName ? `-${hashString(displayName)}` : '';\n\n  return `${font}-${weight}-${style}-${url.length}${hashedDisplayName}`;\n}\n","import { isDefined } from '../../../../core/utils/assertions';\nimport { generateIdForFontRegistrationData } from '../../../utils';\n\nimport { FontAwaiter } from './FontAwaiter';\n\nexport abstract class BaseFontAwaiter implements FontAwaiter {\n  protected fonts = new Map<string, FontFace | Promise<FontFace>>();\n\n  async waitForFontToLoad(\n    font: string,\n    url: string,\n    isBold: boolean,\n    isItalic: boolean,\n  ): Promise<FontFace | null> {\n    return await this.getOrLoadFontFromCache(font, url, isBold, isItalic);\n  }\n\n  protected abstract doWaitForFontToLoad(\n    font: string,\n    url: string,\n    isBold: boolean,\n    isItalic: boolean,\n  ): Promise<FontFace>;\n\n  /**\n   * This method does cache management for the BaseFontAwaiter.\n   * If a fontFace is passed as argument, it will be awaited by the corresponding Awaiter implementation.\n   * If no fontFace is passed, then font face loading will start from zero by creating the instance of fontFace.\n   *\n   * @param font\n   * @param url\n   * @param isBold\n   * @param isItalic\n   * @param fontFace\n   * @returns\n   */\n  private async getOrLoadFontFromCache(\n    font: string,\n    url: string,\n    isBold: boolean,\n    isItalic: boolean,\n  ): Promise<FontFace | null> {\n    const fontKey = this.buildFontKey(font, isBold, isItalic, url);\n\n    if (this.fonts.has(fontKey)) {\n      const fontOrPromise = this.fonts.get(fontKey)!;\n      return fontOrPromise;\n    }\n\n    const fontLoadPromise = this.doWaitForFontToLoad(\n      font,\n      url,\n      isBold,\n      isItalic,\n    ).then((fontFace) => {\n      isDefined(fontFace, 'FontFace is not defined');\n      this.fonts.set(fontKey, fontFace);\n      return fontFace;\n    });\n\n    this.fonts.set(fontKey, fontLoadPromise);\n\n    return fontLoadPromise;\n  }\n\n  private buildFontKey(\n    font: string,\n    isBold: boolean,\n    isItalic: boolean,\n    url: string,\n  ) {\n    return generateIdForFontRegistrationData({\n      font,\n      isBold,\n      isItalic,\n      url,\n      displayName: undefined,\n    });\n  }\n}\n","import { buildFontMetadata } from '../../../utils';\n\nimport { BaseFontAwaiter } from './BaseFontAwaiter';\nimport { FontAwaiter } from './FontAwaiter';\n\n/**\n * Font awaiter based on the FontFace interface.\n * In theory can be used in both DOM and Worker contexts.\n */\nexport class FontFaceFontAwaiter\n  extends BaseFontAwaiter\n  implements FontAwaiter\n{\n  protected async doWaitForFontToLoad(\n    font: string,\n    _url: string,\n    isBold: boolean,\n    isItalic: boolean,\n  ): Promise<FontFace> {\n    try {\n      return await loadFontFace(font, _url, isBold, isItalic);\n    } catch (error) {\n      console.log(\n        `FontFaceFontAwaiter: failed to load font ${font} bold=${isBold} italic=${isItalic}`,\n        error,\n      );\n      throw error;\n    }\n  }\n}\n\nasync function loadFontFace(\n  fontName: string,\n  url: string,\n  isBold: boolean,\n  isItalic: boolean,\n): Promise<FontFace> {\n  const fontMetadata = buildFontMetadata(isBold, isItalic);\n  const response = await fetch(url);\n  const fontData = await response.arrayBuffer();\n  const font = new FontFace(fontName, fontData, fontMetadata);\n  await font.load();\n  return font;\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { FontObserver } from './FontObserver';\n\n/**\n * This Observer just reacts to loaded fonts and adds them to the worker context so they can be used.\n */\nexport class WorkerAdderFontObserver implements FontObserver {\n  loaded(\n    fontName: string,\n    url: string,\n    isBold: boolean,\n    isItalic: boolean,\n    fontFace: FontFace,\n  ): void {\n    self.fonts.add(fontFace);\n  }\n}\n","import { FontRegistrationData, RegisteredFontData } from '../types';\nimport { generateIdForFontRegistrationData } from '../utils';\n\nimport { FontAwaiter } from './dependencies/awaiters/FontAwaiter';\nimport { FontObserver } from './dependencies/observers/FontObserver';\n\nexport interface FontRegistryConfiguration {\n  fontAwaiter: FontAwaiter;\n  observers?: FontObserver[];\n}\n\nexport class FontRegistry {\n  private fonts = new Map<string, RegisteredFontData>();\n\n  constructor(private configuration: FontRegistryConfiguration) {}\n\n  public async registerFont(\n    registrationData: FontRegistrationData,\n  ): Promise<RegisteredFontData> {\n    const { font, isBold, isItalic, url, displayName, isCustom } =\n      registrationData;\n\n    return await this.tryGetFromCacheOrLoadFont(\n      font,\n      displayName,\n      isBold,\n      isItalic,\n      url,\n      isCustom,\n    );\n  }\n\n  public async getFontsData(): Promise<RegisteredFontData[]> {\n    const fonts = Array.from(this.fonts.values()).sort((a, b) =>\n      a.displayName.localeCompare(b.displayName),\n    );\n\n    return fonts;\n  }\n\n  public async tryGetFromCacheOrLoadFont(\n    font: string,\n    displayName: string,\n    isBold: boolean,\n    isItalic: boolean,\n    url: string,\n    isCustom: boolean,\n  ): Promise<RegisteredFontData> {\n    // Create internal cache key\n    const registryKey = this.buildFontKey(\n      font,\n      displayName,\n      isBold,\n      isItalic,\n      url,\n    );\n\n    // Early exit if the font is already in the cache\n    if (this.fonts.has(registryKey)) {\n      return this.fonts.get(registryKey)!;\n    }\n\n    let loadedFontFace: FontFace | null = null;\n\n    try {\n      for (const observer of this.configuration.observers ?? []) {\n        observer.loading?.(font, url, isBold, isItalic);\n      }\n\n      loadedFontFace = await this.configuration.fontAwaiter.waitForFontToLoad(\n        font,\n        url,\n        isBold,\n        isItalic,\n      );\n\n      if (!loadedFontFace) {\n        throw new Error(\n          `FontRegistry: could not await font ${font} bold=${isBold} italic=${isItalic}`,\n        );\n      }\n    } catch (error) {\n      for (const observer of this.configuration.observers ?? []) {\n        observer.errored?.(font, url, isBold, isItalic, loadedFontFace);\n      }\n      throw error;\n    }\n\n    // Finally, if the font or fontFace was loaded correctly, set information in the cache.\n    this.fonts.set(registryKey, {\n      id: registryKey,\n      font,\n      displayName: displayName,\n      isBold,\n      isItalic,\n      url,\n      isCustom,\n      fontFace: loadedFontFace,\n    });\n\n    for (const observer of this.configuration.observers ?? []) {\n      observer.loaded?.(font, url, isBold, isItalic, loadedFontFace);\n    }\n\n    return this.fonts.get(registryKey)!;\n  }\n\n  private buildFontKey(\n    font: string,\n    displayName: string,\n    isBold: boolean,\n    isItalic: boolean,\n    url: string,\n  ) {\n    return generateIdForFontRegistrationData({\n      font,\n      displayName,\n      isBold,\n      isItalic,\n      url,\n    });\n  }\n}\n","import { TextMeasurerInterface } from './types';\n\nexport abstract class BaseTextMeasurer implements TextMeasurerInterface {\n  protected text: string;\n  protected font: string;\n  protected size: number;\n  protected bold: boolean;\n  protected italic: boolean;\n\n  constructor() {\n    this.text = '';\n    this.font = '';\n    this.size = 0;\n    this.bold = false;\n    this.italic = false;\n  }\n\n  withText(text: string) {\n    this.text = text;\n    return this;\n  }\n\n  withFont(font: string) {\n    this.font = font;\n    return this;\n  }\n\n  withSize(size: number) {\n    this.size = size;\n    return this;\n  }\n\n  withBold(bold: boolean = true) {\n    this.bold = bold;\n    return this;\n  }\n\n  withItalic(italic: boolean = true) {\n    this.italic = italic;\n    return this;\n  }\n\n  withParams(params?: Record<string, unknown>) {\n    this.applyParams?.(params);\n    return this;\n  }\n\n  abstract applyParams?(params?: Record<string, unknown>): void;\n\n  // This method must be called last, to return the calculated width of the text.\n  abstract calculateWidth(): number | Promise<number>;\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { isDefined } from '../../core/utils/assertions';\nimport { buildCssStringForFont } from '../../fonts/utils';\n\nimport { BaseTextMeasurer } from './BaseTextMeasurer';\nimport { TextMeasurerInterface } from './types';\n\nexport type RenderingContext =\n  | CanvasRenderingContext2D\n  | OffscreenCanvasRenderingContext2D;\n\nexport class CanvasTextMeasurer\n  extends BaseTextMeasurer\n  implements TextMeasurerInterface\n{\n  private canvasContext: RenderingContext | null;\n  private cache = new Map<string, number>();\n\n  constructor() {\n    super();\n    this.canvasContext = null;\n  }\n\n  withCanvasContext(canvasContext: RenderingContext) {\n    this.canvasContext = canvasContext;\n    return this;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  applyParams?(params?: Record<string, unknown>): void {}\n\n  // This method must be called last, to return the calculated width of the text.\n  calculateWidth() {\n    const fontString = buildCssStringForFont(\n      this.font,\n      this.bold,\n      this.italic,\n      this.size,\n    );\n\n    const key = `${fontString}<>!&%${this.text}`;\n\n    // If the cache does not contain the key (fontString + text), then calculate the width and add it to the cache.\n    if (!this.cache.has(key)) {\n      this.cache.set(key, this.doWidthCalculation(this.text, fontString));\n    }\n\n    return this.cache.get(key)!;\n  }\n\n  // Calculate the width of the text using the canvasContext.measureText() method.\n  private doWidthCalculation(text: string, font: string) {\n    isDefined(this.canvasContext, 'Canvas context is not set');\n\n    this.canvasContext.font = font;\n    return this.canvasContext.measureText(text).width;\n  }\n}\n","import { AllMessages, MessagePayloads } from './messages';\n\ntype WorkerPort = Pick<Worker, 'postMessage'>;\ntype SelfPort = Pick<Window & typeof globalThis, 'postMessage'>;\n\ntype MessagePort = WorkerPort | SelfPort;\n\nfunction isRunningInWorker(): boolean {\n  return typeof self.postMessage === 'function';\n}\n\nexport function postTypedMessage<TMessage extends AllMessages>(\n  messagePort: MessagePort,\n  message: TMessage,\n  params: MessagePayloads[TMessage]['params'],\n  transferrables?: Transferable[],\n  targetOrigin?: string,\n): void {\n  postUntypedMessage(\n    messagePort,\n    message,\n    params,\n    transferrables,\n    targetOrigin,\n  );\n}\n\nexport function postUntypedMessage(\n  messagePort: MessagePort,\n  message: string,\n  params: Record<string, unknown>,\n  transferrables?: Transferable[],\n  targetOrigin?: string,\n): void {\n  if (!transferrables || transferrables.length === 0) {\n    messagePort.postMessage({ message, params });\n    return;\n  }\n\n  if (isRunningInWorker()) {\n    (messagePort as WorkerPort).postMessage(\n      { message, params },\n      transferrables,\n    );\n  } else {\n    (messagePort as SelfPort).postMessage(\n      { message, params },\n      targetOrigin ?? '/',\n      transferrables,\n    );\n  }\n}\n\nexport function isMessageOfType<TMessage extends AllMessages>(\n  event: MessageEvent<unknown>,\n  message: TMessage,\n): event is MessageEvent<MessagePayloads[TMessage]> {\n  return (event.data as MessagePayloads[TMessage]).message === message;\n}\n\nexport function isMessageOfTypeUntyped(\n  event: MessageEvent<unknown>,\n  message: string,\n): event is MessageEvent<Record<string, unknown>> {\n  return (event.data as { message: string }).message === message;\n}\n\nexport function logObjectKeys(\n  obj: Record<string, unknown>,\n  logFn: (key: string, value: unknown) => void,\n  excludeKeysRegex: RegExp = /canvas/,\n): void {\n  for (const [key, value] of Object.entries(obj)) {\n    if (excludeKeysRegex.test(key)) {\n      continue;\n    }\n\n    logFn(key, value);\n\n    if (typeof value === 'object' && value !== null) {\n      logObjectKeys(value as Record<string, unknown>, logFn);\n    }\n  }\n}\n\nexport function isCanvasDetached(canvas: OffscreenCanvas): boolean {\n  try {\n    canvas.transferControlToOffscreen();\n    return false;\n  } catch (e) {\n    return (e as { code: number }).code === DOMException.INVALID_STATE_ERR;\n  }\n}\n","const RESULT_STRING_KEY = ':result' as const;\n\nexport type ResultKey<T extends string> = `${T}${typeof RESULT_STRING_KEY}`;\n\nexport function getResultKey<T extends string>(key: T): ResultKey<T> {\n  return `${key}${RESULT_STRING_KEY}` as ResultKey<T>;\n}\n\n/**\n * Message keys to be SENT to web workers\n */\nexport type WorkerMessageType =\n  | 'initialize'\n  | 'measureText'\n  | 'fontLoaded'\n  | 'fonts:synchronize';\n\n/**\n * Message keys to be RECEIVED from web workers\n */\nexport type MainThreadMessageType =\n  | ResultKey<'initialize'>\n  | ResultKey<'measureText'>\n  | ResultKey<'fontLoaded'>\n  | ResultKey<'fonts:synchronize'>;\n\nexport type AllMessages = WorkerMessageType | MainThreadMessageType;\n\nexport interface Message<TParams = unknown> {\n  message: WorkerMessageType;\n  params: TParams;\n}\n\nexport type InitializeMessage = Message<{\n  id: string;\n}>;\n\n/**\n * Dummy type\n */\nexport type InitializeResultMessage = Message<{\n  id: string;\n}>;\n\nexport type MeasureTextMessage = Message<{\n  text: string;\n  font: string;\n  size: number;\n  bold: boolean;\n  italic: boolean;\n  canvas?: OffscreenCanvas;\n  canvasMode: 'transferred' | 'created';\n}>;\n\nexport type MeasureTextResultMessage = Message<{\n  text: string;\n  result: number;\n}>;\n\nexport type FontLoadedMessage = Message<{\n  fontName: string;\n  url: string;\n  isBold: boolean;\n  isItalic: boolean;\n}>;\n\nexport type FontLoadedResultMessage = Message<{\n  status: 'loaded' | 'error';\n}>;\n\nexport type SynchronizeFontsMessage = Message<{\n  fonts: {\n    fontName: string;\n    url: string;\n    isBold: boolean;\n    isItalic: boolean;\n  }[];\n}>;\n\nexport type SynchronizeFontsMessageResult = Message<{\n  status: 'success' | 'error';\n}>;\n\nexport interface MessagePayloads {\n  initialize: InitializeMessage;\n  ['initialize:result']: InitializeResultMessage;\n  measureText: MeasureTextMessage;\n  ['measureText:result']: MeasureTextResultMessage;\n  ['fontLoaded']: FontLoadedMessage;\n  ['fontLoaded:result']: FontLoadedResultMessage;\n  ['fonts:synchronize']: SynchronizeFontsMessage;\n  ['fonts:synchronize:result']: SynchronizeFontsMessageResult;\n}\n\nexport type MessageParams<TMessage extends keyof MessagePayloads> =\n  MessagePayloads[TMessage]['params'];\n","import {\n  WorkerMessageType,\n  MessageParams,\n  ResultKey,\n  Message,\n  getResultKey,\n} from '../messages';\nimport {\n  isMessageOfType,\n  isMessageOfTypeUntyped,\n  postTypedMessage,\n  postUntypedMessage,\n} from '../utils';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype MessageHandlerReturnType<TMessage extends WorkerMessageType> =\n  MessageParams<ResultKey<TMessage>> extends never\n    ? Promise<void>\n    : Promise<MessageParams<ResultKey<TMessage>>>;\n\n/**\n * This method is to be used INSIDE WEBWORKERS.\n * It handles incoming messages from the main thread, and apply the message\n * handler function to generate and send the result message pair\n * @param message message type to process\n * @param event message event\n * @param messageHandler function to be called when the message is received, with the incoming message\n * params. It should return a promise that resolves to the result message params.\n * @returns promise resolving to true if the message was handled, false otherwise\n */\nexport async function handleMessageFromWorker<\n  TMessage extends WorkerMessageType,\n>(\n  message: TMessage,\n  event: MessageEvent<Message /*<MessageParams<TMessage>>*/>,\n  messageHandler: (\n    params: MessageParams<TMessage>,\n  ) => Promise<MessageParams<ResultKey<TMessage>>>,\n) {\n  if (!isMessageOfType(event, message)) {\n    return false;\n  }\n\n  // log(`Received ${message} message`);\n\n  const data = event.data;\n\n  // logObjectKeys(data.params, (key, value) =>\n  //   log(`- data.params.${key}=${value}`),\n  // );\n\n  const resultPayload = await messageHandler(data.params);\n\n  if (resultPayload) {\n    postTypedMessage(\n      event.target as Worker,\n      getResultKey(message),\n      resultPayload,\n    );\n  }\n\n  return true;\n}\n\n/**\n * This method is to be used IN THE MAIN THREAD.\n * It handles sending a message to a given web worker, and waits for the result message in a promise.\n * @param worker worker to send the message to\n * @param message message type\n * @param params message params\n * @param resultCallback optional callback to be called when the result message is received, to manually convert data if necessary.\n * @param transferrables optional list of transferrable objects to be sent to the worker.\n * @returns promise resolving to the result message params.\n */\nexport function handleMessageFromMainThread<TMessage extends WorkerMessageType>(\n  worker: Worker,\n  message: TMessage,\n  params: MessageParams<TMessage>,\n  resultCallback?: (\n    params: MessageParams<TMessage>,\n    result: MessageParams<ResultKey<TMessage>>,\n    resolve: (value: MessageParams<ResultKey<TMessage>>) => void,\n    reject: (reason?: unknown) => void,\n  ) => Promise<void>,\n  transferrables?: Transferable[],\n): Promise<MessageParams<ResultKey<TMessage>>> {\n  return handleMessageFromMainThreadUntyped(\n    worker,\n    message,\n    params,\n    // @ts-expect-error conversion between too specific and too generic types\n    resultCallback,\n    transferrables,\n  ) as Promise<MessageParams<ResultKey<TMessage>>>;\n}\n\n/**\n * This method is to be used IN THE MAIN THREAD.\n * It handles sending a message to a given web worker, and waits for the result message in a promise.\n * @param worker worker to send the message to\n * @param message message type\n * @param params message params\n * @param resultCallback optional callback to be called when the result message is received, to manually convert data if necessary.\n * @param transferrables optional list of transferrable objects to be sent to the worker.\n * @returns promise resolving to the result message params.\n */\nexport function handleMessageFromMainThreadUntyped(\n  worker: Worker,\n  message: string,\n  params: unknown,\n  resultCallback?: (\n    params: unknown,\n    result: unknown,\n    resolve: (value: unknown) => void,\n    reject: (reason?: unknown) => void,\n  ) => Promise<void>,\n  transferrables?: Transferable[],\n): Promise<unknown> {\n  return new Promise<unknown>((resolve, reject) => {\n    worker.onmessage = (event: MessageEvent<Message>) => {\n      if (!isMessageOfTypeUntyped(event, getResultKey(message))) {\n        return;\n      }\n\n      if (resultCallback) {\n        resultCallback(params, event.data.params, resolve, reject);\n        return;\n      }\n\n      resolve(event.data.params);\n    };\n\n    worker.onerror = (error) => {\n      console.log('REJECT', error);\n      reject(error);\n    };\n\n    postUntypedMessage(\n      worker,\n      message,\n      params as Record<string, unknown>,\n      transferrables,\n    );\n  });\n}\n","// Define a type for the message that the worker will receive\n\nimport { isDefined } from '../../../core/utils/assertions';\nimport { FontFaceFontAwaiter } from '../../../fonts/registry/dependencies/awaiters/FontFaceFontAwaiter';\nimport { WorkerAdderFontObserver } from '../../../fonts/registry/dependencies/observers/WorkerAdderFontObserver';\nimport { FontRegistry } from '../../../fonts/registry/FontRegistry';\nimport { CanvasTextMeasurer } from '../../../text-measuring/measurers/CanvasTextMeasurer';\nimport { Message } from '../../messages';\nimport { logObjectKeys } from '../../utils';\nimport { handleMessageFromWorker } from '../worker-utils';\n\nlet workerId: string | null = null;\nlet WORKER_CANVAS: OffscreenCanvas | undefined;\n\nconst fontRegistry: FontRegistry = new FontRegistry({\n  fontAwaiter: new FontFaceFontAwaiter(),\n  observers: [new WorkerAdderFontObserver()],\n});\n\nfunction log(...args: unknown[]): void {\n  console.log(`[SimpleWebWorker ${workerId}]`, ...args);\n}\n\nasync function handleInitializeMessage(\n  event: MessageEvent<Message>,\n): Promise<boolean> {\n  return await handleMessageFromWorker('initialize', event, async (params) => {\n    workerId = params.id;\n    log(`Worker initialized with ID ${workerId}`);\n    return { id: workerId };\n  });\n}\n\nasync function handleFontLoadedMessage(\n  event: MessageEvent<Message>,\n): Promise<boolean> {\n  return await handleMessageFromWorker('fontLoaded', event, async (params) => {\n    log(`Received fontLoaded message`);\n\n    log(`Registering font ${params.fontName} from ${params.url}`);\n\n    const fontRegistrationData = await fontRegistry.registerFont({\n      font: params.fontName,\n      url: params.url,\n      isBold: params.isBold,\n      isItalic: params.isItalic,\n      displayName: `${params.fontName} [webworker]`,\n      isCustom: true,\n    });\n\n    log(\n      `Registered font ${params.fontName} from ${params.url}, status: ${fontRegistrationData.fontFace?.status}`,\n    );\n\n    return {\n      status: 'loaded',\n    };\n  });\n}\n\nasync function handleFontSynchronizeMessage(event: MessageEvent<Message>) {\n  return await handleMessageFromWorker(\n    'fonts:synchronize',\n    event,\n    async (params) => {\n      log('Received fontSynchronize message');\n\n      log('Synchronizing fonts');\n\n      const fontsSynchronizedPromise = params.fonts.map(async (font) => {\n        return await fontRegistry.registerFont({\n          font: font.fontName,\n          url: font.url,\n          isBold: font.isBold,\n          isItalic: font.isItalic,\n          displayName: `${font.fontName} [webworker]`,\n          isCustom: true,\n        });\n      });\n\n      await Promise.all(fontsSynchronizedPromise);\n\n      log('Synchronized fonts');\n\n      return {\n        status: 'success',\n      };\n    },\n  );\n}\n\nasync function handleMeasureTextMessage(\n  event: MessageEvent<Message>,\n): Promise<boolean> {\n  return await handleMessageFromWorker('measureText', event, async (params) => {\n    log(`Received measureText message`);\n\n    logObjectKeys(params, (key, value) => log(`- params.${key}=${value}`));\n\n    let canvas: undefined | OffscreenCanvas;\n\n    if (params.canvasMode === 'transferred') {\n      log('Using canvas transferred from main thread');\n      canvas = params.canvas;\n    } else if (params.canvasMode === 'created') {\n      if (!WORKER_CANVAS) {\n        log('Creating canvas in worker');\n        canvas = new OffscreenCanvas(300, 150);\n        WORKER_CANVAS = canvas;\n      } else {\n        log('Reusing canvas in worker');\n        canvas = WORKER_CANVAS;\n      }\n    }\n\n    isDefined(canvas, 'Canvas is not set');\n\n    const context = canvas.getContext('2d')!;\n\n    // Just to reuse something from the main application\n    const measurer = new CanvasTextMeasurer()\n      .withText(params.text)\n      .withFont(params.font)\n      .withBold(params.bold)\n      .withItalic(params.italic)\n      .withSize(params.size)\n      .withCanvasContext(context);\n\n    const result = measurer.calculateWidth();\n\n    log(`Sending result: ${result}`);\n\n    return {\n      text: params.text,\n      result,\n    };\n  });\n}\n\nasync function handleWorkerMessage(\n  event: MessageEvent<Message>,\n): Promise<void> {\n  const { message } = event.data;\n\n  if (await handleInitializeMessage(event)) {\n    return;\n  }\n\n  if (await handleFontLoadedMessage(event)) {\n    return;\n  }\n\n  if (await handleFontSynchronizeMessage(event)) {\n    return;\n  }\n\n  if (await handleMeasureTextMessage(event)) {\n    return;\n  }\n\n  log(`Unknown message: ${message}`);\n}\n\n// Add an event listener to the worker to handle incoming messages\nself.addEventListener('message', handleWorkerMessage);\n"],"names":["isDefined","value","errorMessage","hashString","str","hash","i","char","DEFAULT_FONT_SIZE","buildCssStringForFont","fontName","isBold","isItalic","fontSize","fontString","buildFontMetadata","generateIdForFontRegistrationData","fontRegistrationData","font","displayName","url","weight","style","hashedDisplayName","BaseFontAwaiter","__publicField","fontKey","fontLoadPromise","fontFace","FontFaceFontAwaiter","_url","loadFontFace","error","fontMetadata","fontData","WorkerAdderFontObserver","FontRegistry","configuration","registrationData","isCustom","a","b","registryKey","loadedFontFace","observer","_a","_b","_c","BaseTextMeasurer","text","size","bold","italic","params","CanvasTextMeasurer","canvasContext","key","isRunningInWorker","postTypedMessage","messagePort","message","transferrables","targetOrigin","postUntypedMessage","isMessageOfType","event","logObjectKeys","obj","logFn","excludeKeysRegex","RESULT_STRING_KEY","getResultKey","handleMessageFromWorker","messageHandler","data","resultPayload","workerId","WORKER_CANVAS","fontRegistry","log","args","handleInitializeMessage","handleFontLoadedMessage","handleFontSynchronizeMessage","fontsSynchronizedPromise","handleMeasureTextMessage","canvas","context","result","handleWorkerMessage"],"mappings":"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"}