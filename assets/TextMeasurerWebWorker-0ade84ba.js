var G=Object.defineProperty;var V=(l,f,d)=>f in l?G(l,f,{enumerable:!0,configurable:!0,writable:!0,value:d}):l[f]=d;var u=(l,f,d)=>(V(l,typeof f!="symbol"?f+"":f,d),d);(function(){"use strict";function l(o,t){if(o==null)throw new Error(t)}function f(o){let t=0;for(let e=0;e<o.length;e++){const n=o.charCodeAt(e);t=(t<<5)-t+n,t|=0}return t.toString()}const d=14;function S(o,t,e,n=d){let s="";return t&&(s+="bold "),e&&(s+="italic "),s+=`${n}px "${o}"`,s}function T(o,t){return{weight:o?"bold":"normal",style:t?"italic":"normal"}}function $(o){const{font:t,displayName:e,isBold:n,isItalic:s,url:i}=o,c=n?"bold":"normal",a=s?"italic":"normal",w=e?`-${f(e)}`:"";return`${t}-${c}-${a}-${i.length}${w}`}class N{constructor(){u(this,"fonts",new Map)}async waitForFontToLoad(t,e,n,s){return await this.getOrLoadFontFromCache(t,e,n,s)}async getOrLoadFontFromCache(t,e,n,s){const i=this.buildFontKey(t,n,s,e);if(this.fonts.has(i))return this.fonts.get(i);const c=this.doWaitForFontToLoad(t,e,n,s).then(a=>(l(a,"FontFace is not defined"),this.fonts.set(i,a),a));return this.fonts.set(i,c),c}buildFontKey(t,e,n,s){return $({font:t,isBold:e,isItalic:n,url:s,displayName:void 0})}}class R extends N{async doWaitForFontToLoad(t,e,n,s){try{return await p(t,e,n,s)}catch(i){throw console.log(`FontFaceFontAwaiter: failed to load font ${t} bold=${n} italic=${s}`,i),i}}}async function p(o,t,e,n){const s=T(e,n),c=await(await fetch(t)).arrayBuffer(),a=new FontFace(o,c,s);return await a.load(),a}class z{loaded(t,e,n,s,i){self.fonts.add(i)}}class L{constructor(t){u(this,"fonts",new Map);this.configuration=t}async registerFont(t){const{font:e,isBold:n,isItalic:s,url:i,displayName:c,isCustom:a}=t;return await this.tryGetFromCacheOrLoadFont(e,c,n,s,i,a)}async getFontsData(){return Array.from(this.fonts.values()).sort((e,n)=>e.displayName.localeCompare(n.displayName))}async tryGetFromCacheOrLoadFont(t,e,n,s,i,c){var v,M,b;const a=this.buildFontKey(t,e,n,s,i);if(this.fonts.has(a))return this.fonts.get(a);let w=null;try{for(const h of this.configuration.observers??[])(v=h.loading)==null||v.call(h,t,i,n,s);if(w=await this.configuration.fontAwaiter.waitForFontToLoad(t,i,n,s),!w)throw new Error(`FontRegistry: could not await font ${t} bold=${n} italic=${s}`)}catch(h){for(const m of this.configuration.observers??[])(M=m.errored)==null||M.call(m,t,i,n,s,w);throw h}this.fonts.set(a,{id:a,font:t,displayName:e,isBold:n,isItalic:s,url:i,isCustom:c,fontFace:w});for(const h of this.configuration.observers??[])(b=h.loaded)==null||b.call(h,t,i,n,s,w);return this.fonts.get(a)}buildFontKey(t,e,n,s,i){return $({font:t,displayName:e,isBold:n,isItalic:s,url:i})}}class k{constructor(){u(this,"text");u(this,"font");u(this,"size");u(this,"bold");u(this,"italic");this.text="",this.font="",this.size=0,this.bold=!1,this.italic=!1}withText(t){return this.text=t,this}withFont(t){return this.font=t,this}withSize(t){return this.size=t,this}withBold(t=!0){return this.bold=t,this}withItalic(t=!0){return this.italic=t,this}withParams(t){var e;return(e=this.applyParams)==null||e.call(this,t),this}}class W extends k{constructor(){super();u(this,"canvasContext");u(this,"cache",new Map);this.canvasContext=null}withCanvasContext(e){return this.canvasContext=e,this}applyParams(e){}calculateWidth(){const e=S(this.font,this.bold,this.italic,this.size),n=`${e}<>!&%${this.text}`;return this.cache.has(n)||this.cache.set(n,this.doWidthCalculation(this.text,e)),this.cache.get(n)}doWidthCalculation(e,n){return l(this.canvasContext,"Canvas context is not set"),this.canvasContext.font=n,this.canvasContext.measureText(e).width}}function O(){return typeof self.postMessage=="function"}function A(o,t,e,n,s){K(o,t,e,n,s)}function K(o,t,e,n,s){if(!n||n.length===0){o.postMessage({message:t,params:e});return}O()?o.postMessage({message:t,params:e},n):o.postMessage({message:t,params:e},s??"/",n)}function D(o,t){return o.data.message===t}function x(o,t,e=/canvas/){for(const[n,s]of Object.entries(o))e.test(n)||(t(n,s),typeof s=="object"&&s!==null&&x(s,t))}const E=":result";function I(o){return`${o}${E}`}async function g(o,t,e){if(!D(t,o))return!1;const n=t.data,s=await e(n.params);return s&&A(t.target,I(o),s),!0}let y=null,F;const C=new L({fontAwaiter:new R,observers:[new z]});function r(...o){console.log(`[SimpleWebWorker ${y}]`,...o)}async function P(o){return await g("initialize",o,async t=>(y=t.id,r(`Worker initialized with ID ${y}`),{id:y}))}async function U(o){return await g("fontLoaded",o,async t=>{var n;r("Received fontLoaded message"),r(`Registering font ${t.fontName} from ${t.url}`);const e=await C.registerFont({font:t.fontName,url:t.url,isBold:t.isBold,isItalic:t.isItalic,displayName:`${t.fontName} [webworker]`,isCustom:!0});return r(`Registered font ${t.fontName} from ${t.url}, status: ${(n=e.fontFace)==null?void 0:n.status}`),{status:"loaded"}})}async function _(o){return await g("fonts:synchronize",o,async t=>{r("Received fontSynchronize message"),r("Synchronizing fonts");const e=t.fonts.map(async n=>await C.registerFont({font:n.fontName,url:n.url,isBold:n.isBold,isItalic:n.isItalic,displayName:`${n.fontName} [webworker]`,isCustom:!0}));return await Promise.all(e),r("Synchronized fonts"),{status:"success"}})}async function B(o){return await g("measureText",o,async t=>{r("Received measureText message"),x(t,(c,a)=>r(`- params.${c}=${a}`));let e;t.canvasMode==="transferred"?(r("Using canvas transferred from main thread"),e=t.canvas):t.canvasMode==="created"&&(F?(r("Reusing canvas in worker"),e=F):(r("Creating canvas in worker"),e=new OffscreenCanvas(300,150),F=e)),l(e,"Canvas is not set");const n=e.getContext("2d"),i=new W().withText(t.text).withFont(t.font).withBold(t.bold).withItalic(t.italic).withSize(t.size).withCanvasContext(n).calculateWidth();return r(`Sending result: ${i}`),{text:t.text,result:i}})}async function j(o){const{message:t}=o.data;await P(o)||await U(o)||await _(o)||await B(o)||r(`Unknown message: ${t}`)}self.addEventListener("message",j)})();
//# sourceMappingURL=TextMeasurerWebWorker-0ade84ba.js.map
